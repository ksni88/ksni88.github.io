<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/uploads/head.png?v=0.5.0" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="栖静林">
<meta property="og:url" content="http://ksni88.github.io/index.html">
<meta property="og:site_name" content="栖静林">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="栖静林">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 6269574853532059000,
      author: '博主'
    }
  };
</script>

  <title> 栖静林 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?dc8c3422caa41521411bcb96984a10f6";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">栖静林</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">不忘初心，方得始终</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/从零爬Hadoop系列_5-《Hadoop技术内幕2》计算框架/" itemprop="url">
                  从零爬Hadoop系列_5-《Hadoop技术内幕2》计算框架
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-24T19:54:48+08:00" content="2016-07-24">
              2016-07-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Hadoop/" itemprop="url" rel="index">
                    <span itemprop="name">Hadoop</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/从零爬Hadoop系列_5-《Hadoop技术内幕2》计算框架/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="从零爬Hadoop系列_5-《Hadoop技术内幕2》计算框架/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计算框架"><a href="#计算框架" class="headerlink" title="计算框架"></a>计算框架</h1><p>现在有很多计算框架，各有特点，各有应用场景，该篇主要介绍MR，简短介绍Tez、Storm、Spark。</p>
<h2 id="MapReduce-On-YARN"><a href="#MapReduce-On-YARN" class="headerlink" title="MapReduce On YARN"></a>MapReduce On YARN</h2><p>预备知识：由于YARN是一个资源管理系统，如果想要将一个新的应用程序（采用某个计算框架的作业）运行在YARN之上，通常需要编写两个组件来“对接移植”：  </p>
<ol>
<li>Client客户端：用户通过客户端向RM提交AM，并查询作业的运行状态</li>
<li>AM：AM负责向RM申请资源，并和NM通信启动各个Contianer（内部任务），以及监控各个任务运行状态，失败重新申请等  </li>
</ol>
<p>所以对于YARN来说，不变的是RM（共享集群的资源调度）、NM（节点代理），可变的是计算框架（应用程序），这里的可变即通过编写自己的AM完成，再明了一点，即各个计算框架是通过编写各自的AM集成到YARN上以实现多个框架共享集群的，而本章的主要内容就是讲MR的AM。  </p>
<p>看过前边的应该记得，YARN是由MRv1进化而来的，所以YARN天生支持MR，即提供了可以直接使用的AM：MRAppMaster，为了更好的理解，可以先来看一下两者的异同：  </p>
<p><img src="http://cevxd.img48.wal8.com/img48/542077_20160404152451/146936512189.png" alt="image">  </p>
<p>即只有原来负责资源调度和任务管理的运行时环境发生了替换，其他还是原来的代码。</p>
<p>名词解释：</p>
<ol>
<li>作业：前文中“应用程序”的另一个叫法</li>
<li>任务：前文中应用程序的内部子任务</li>
<li>MT：Map Task</li>
<li>RT：Reduce Task</li>
</ol>
<h2 id="MR客户端"><a href="#MR客户端" class="headerlink" title="MR客户端"></a>MR客户端</h2><ol>
<li>MR客户端是MR用户与YARN（和MRAppMaster）进行通信的唯一途径，通过客户端完成提交作业、获取作业运行状态和控制作业（杀死作业、杀死任务等）</li>
<li>两个RPC通信协议：<ul>
<li>ApplicationClientProtocol：任何客户端需使用该协议完成提交作业、杀死作业、改变作业优先级等作业（等同于前文一直提的应用程序）级别的操作</li>
<li>MRClientProtocol：当作业的AM启动成功以后，它会启动MRClientService，该服务实现了此协议，客户端通过该协议和AM通信，完成控制作业和查询作业运行状态等操作（偏向任务级别的操作），减轻RM的负载</li>
</ul>
</li>
</ol>
<h2 id="MRAppMaster"><a href="#MRAppMaster" class="headerlink" title="MRAppMaster"></a>MRAppMaster</h2><ol>
<li>基本构成：  <ul>
<li><code>ContainerAllocator</code>：与RM通信，为MR任务申请资源（因为AM的提交时由客户端完成的，而且对应Container的启动是RM直接告知NM的，所以不经它手，它只负责内部任务）</li>
<li><code>ClientService</code>：是一个接口，由MRClientService实现，负责上边提到的MRClientProtocol通信协议的功能</li>
<li><code>Job</code>：表示一个MR作业，即一个MR应用程序，功能和MRv1的JobInProgress类似，监控一个作业的运行状态，它维护了一个作业状态机，实现异步操作</li>
<li><code>Task</code>：表示一个MR作业中的某个任务，与MRv1中的TaskInProgress功能类似，监控一个任务的运行状态，它维护了一个任务状态机，实现异步操作</li>
<li><code>TaskAttempt</code>：表示一个任务的运行实例，它的执行逻辑和MRv1中的MapTask和ReduceTask运行实例完全一致，只是有一些优化</li>
<li><code>TaskCleaner</code>：负责清理失败任务或被杀死任务使用的目录和产生的临时结果，它为了一个线程池和共享队列，异步删除</li>
<li><code>Speculator</code>：负责推测执行功能，即当一个作业的某个任务运行速度明显慢于其他任务时，它会为其启动一个备份任务，谁先执行完谁作为最终结果，并杀死另一个</li>
<li><code>ContainerLauncher</code>：负责和NM通信，以启动Container，这里需要注意，后文详细介绍</li>
<li><code>TaskAttemptListener</code>：负责管理各个任务的心跳信息，同MRv1中的TaskTracker类似</li>
<li><code>JobHistoryEventHandler</code>：负责对作业的各个事件记录日志，这些日志会写到HDFS上，主要用于MRAppMaster故障时作业恢复和历史查看</li>
</ul>
</li>
<li>三种作业运行模式：  <ul>
<li>本地模式：通常用于作业调试，和MRv1一样</li>
<li>Uber模式：所有内部任务以先Map Task后Reduce Task的顺序串行重用同一个Container，主要用于小作业，降低延时</li>
<li>Non-Uber模式：用于大作业：<ul>
<li>Task分为四种状态：  <ul>
<li><code>pending</code>：刚启动但尚未向RM请求资源</li>
<li><code>scheduled</code>：向RM请求资源但尚未分配</li>
<li><code>assigned</code>：分配到资源且正在运行</li>
<li><code>completed</code>：已运行完成</li>
</ul>
</li>
<li>Map Task生命周期：scheduled -&gt; assigned -&gt; completed</li>
<li>Reduce Task生命周期：pending -&gt; scheduled -&gt; assigned -&gt; completed</li>
<li>因为reduce依赖于map的结果，而且在YARN中不在有Map Slot和Reduce Slot之分，为了防止过早启动Reduce Task造成资源利用率低下和Map Task饿死，MRAppMaster由三个参数控制其启动时机：  <ul>
<li><code>mapreduce.job.reduce.slowstart.completedmaps</code>：当Map Task完成的比例达到该值后才会为Reduce Task申请资源，默认为0.5</li>
<li><code>yarn.app.mapreduce.am.job.reduce.rampup.limit</code>：在MT完成前，最多启动的RT比例，默认为0.5</li>
<li><code>yarn.app.mapreduce.am.job.reduce.preemption.limit</code>：当MT需要资源暂时无法获取资源时，为了保证至少一个MT可以得到资源，最多可以抢占的RT比例，默认为0.5</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>MRAppMaster工作流程：  <ul>
<li>和之前YARN的工作流程完全相同，只是把AM替换为MRAppMaster</li>
</ul>
</li>
<li>MR作业表示方式：  <ul>
<li><code>Job</code>：一个MR作业（应用程序），负责整个job即各个task的监控和管理</li>
<li><code>Task</code>：作业内部的任务，此处有MT和RT，负责下面各个taskAttemp的监控和管理</li>
<li><code>TaskAttempt</code>：task真正的运行实例，负责真正的任务计算工作，在YARN中，任务实例是运行在Container中的<br><img src="http://cevxd.img48.wal8.com/img48/542077_20160404152451/146936512323.png" alt="image"></li>
</ul>
</li>
<li>MR作业生命周期：  <ul>
<li>三种状态机：<code>Job状态机</code>、<code>Task状态机</code>、<code>TaskAttempt状态机</code>，属于层级包含关系</li>
<li>状态机内部即基于事件驱动的状态转移，详情请翻书<br><img src="http://cevxd.img48.wal8.com/img48/542077_20160404152451/146936512238.png" alt="image"></li>
</ul>
</li>
<li><p>资源申请和再分配（ContainerAllocator）：  </p>
<ul>
<li>当用户提交作业之后，MRAppMaster会为之初始化，并创建一系列MT和RT，并为它们申请资源</li>
<li>资源请求是通过getResource()函数向RM发送心跳信息完成的：  <ul>
<li>大部分情况下，心跳信息中不包含新的资源请求信息</li>
<li>作用：  <ul>
<li>周期性心跳，告诉RM自己活着</li>
<li>周期性询问RM，获取分配的资源、节点更新列表（新增的、不可用的）等</li>
</ul>
</li>
</ul>
</li>
<li><p>工作流程：  </p>
<ul>
<li>步骤1：将MT的资源需求发送给RM</li>
<li>步骤2：如果达到了RT的启动条件，则开始为RT申请资源</li>
<li>步骤3：如果为某个Task申请到了资源，则取消其他重复资源的申请，由于在HDFS中，任何一份数据通常有三备份，而对于一个任务而言，考虑到reack和any级别的本地性，它可能对应7个资源请求：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. &lt;20, &quot;node1&quot;, &quot;memory:1G&quot;, 1, true&gt;</span><br><span class="line">2. &lt;20, &quot;node2&quot;, &quot;memory:1G&quot;, 1, true&gt;</span><br><span class="line">3. &lt;20, &quot;node3&quot;, &quot;memory:1G&quot;, 1, true&gt;</span><br><span class="line">4. &lt;20, &quot;rack1&quot;, &quot;memory:1G&quot;, 1, true&gt;</span><br><span class="line">5. &lt;20, &quot;rack1&quot;, &quot;memory:1G&quot;, 1, true&gt;</span><br><span class="line">6. &lt;20, &quot;rack1&quot;, &quot;memory:1G&quot;, 1, true&gt;</span><br><span class="line">7. &lt;20, &quot;*&quot;, &quot;memory:1G&quot;, 1, true&gt;</span><br><span class="line">8. &lt;优先级，期望资源所在的host，资源量，Container数目，是否松弛本地性&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>在作业运行过程中，会出现资源重新申请和资源取消的行为：  </p>
<ul>
<li>如果任务运行失败，则会重新为其申请资源</li>
<li>如果一个任务运行速度过慢，则会为其额外申请资源以启动备份任务（推测执行功能）</li>
<li>如果一个节点失败的任务数目过多，则会撤销对该节点的所有资源的申请请求</li>
</ul>
</li>
<li>资源再分配：  <ul>
<li>再分配即之前资源调度模型：双层调度模型的第二层，AM申请到Container以后，再自主的分配给各个任务，具体的分配策略由AM自己决定</li>
<li>MRAppMaster再分配过程：  <ul>
<li>判断收到的Container包含的资源是否满足要求，如果不满足，则通过下次心跳通知RM释放该Container</li>
<li>判断收到的Container所在节点是否被加入黑名单，如果是，则寻找一个与该Container匹配的任务，并重新为该任务申请资源，同时通过下次心跳通知RM释放该Container</li>
<li>根据Container的优先级，将它分配给对应类型的任务：  <ul>
<li>优先级为PRIORITY_FAST_FAIL_MAP：则分配给失败的MT，直接从对应的队列中取出第一个任务即可</li>
<li>优先级为PRIORITY_REDUCE：则分配给RT，直接从对应的队列中取出第一个任务即可</li>
<li>其他的，分配给正常的MT，依次尝试从node-local（输入数据和Container同一个节点）、rack-local和no-local几个任务列表中查找MT</li>
</ul>
</li>
</ul>
</li>
<li>黑名单：  <ul>
<li>当作业在一个节点上失败的任务实例数目超过一定的上限（默认3，默认开启），则该节点将被加入黑名单</li>
<li>为了防止大量节点被加入黑名单，可以通过参数设定最多加入的比例，默认33%</li>
</ul>
</li>
<li>个人理解：<ul>
<li>Container是否满足要求是分配过来以后AM判断的，RM只按照对应的调度器策略进行分配，而没有检查是否满足需求量？</li>
<li>RM的黑名单和AM的黑名单是不同的两个黑名单，不要搞混；</li>
<li>AM提交的只是资源需求，而且这个请求没有和内部的某个具体任务绑定在一起，只是通过级别绑定了任务类型，拿到资源以后还要再次挑选任务进行分配，分配到具体的任务身上以后，再把任务运行所需的资源放进Container，再发送给对应的NM启动Container；所以Container在不同的组件中表示的含义不太相同，在RM中只表示资源需求，在AM中表示任务描述，在NM中表示任务</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Container启动和释放  <ul>
<li>在YARN中，运行Task所需的全部信息被封装到Container中，包括所需资源、依赖的外部文件、JAR包、运行时环境变量、运行命令等</li>
<li>ContainerLauncher通过RPC协议ContainerManager和NM通信，以控制Container的启动和释放，进而达到控制任务（启动、杀死等）的效果</li>
<li>释放：Container运行结束以后，不是自己主动清理物理资源进行上报的，而是等着AM发送kill命令，然后才清理物理资源上报RM的</li>
</ul>
</li>
<li><p>推测执行机制  </p>
<ul>
<li>作用：防止个别任务拖后腿，通过内部竞争竞速完成</li>
<li><p>算法核心思想：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">estimatedRunTime  = (currentTimestamp - taskAttemptStartTime) / progress</span><br><span class="line">estimatedEndTime1 = estimatedRunTime + taskAttemptStartTime</span><br><span class="line">estimatedEndTime2 = currentTimestamp + averageRunTime </span><br><span class="line">estimatedEndTime1  - estimatedEndTime2 差值越大，理论收益越大；</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了避免浪费资源，启动备份任务之前还要检查一些条件：  </p>
<ul>
<li>每个任务同时启动的备份任务实例的上限，三个参数值中的最大值：<ul>
<li><code>MINIMUM_ALLOWED_SPECULATIVE_TASKS（常量10）</code></li>
<li><code>PROPORTION_TOTAL_TASKS_SPECULATABLE(常量0.01)*totalTaskNumber</code></li>
<li><code>PROPORTION_RUNNING_TASKS_SPECULATABLE(常量0.1)*numberRunningTasks</code></li>
</ul>
</li>
<li>已经完成的任务数目比例不小于<code>MINIMUM_COMPLETE_PROPORTION_TO_SPECULATE(默认0.05)</code>，只有这样才能有足够的历史信息估算<code>averageRunTime</code> ；</li>
</ul>
</li>
</ul>
</li>
<li>作业恢复<ul>
<li>三种恢复粒度： <ul>
<li><code>作业级别</code></li>
<li><code>任务级别</code>（MRAppMater采用该级别）</li>
<li><code>记录级别</code></li>
</ul>
</li>
<li>实现方式：MRAppMater采用Avro记录了运行时的各种事件，通过读取解析，重做这些日志，以重构作业或任务的内存信息，进而使作业从断点继续执行</li>
<li>过程：<ul>
<li>MRAppMater初始化时，解析前一次记录的事件日志，并将运行完成的任务存放到<code>completedTasksFromPreviousRun</code>（类型为<code>Map&lt;TaskId,TaskInfo&gt;</code>）中</li>
<li>MRAppMater构建新的<code>JobImpl</code>对象，并将<code>completedTasksFromPreviousRun</code>传递给该对象的构造函数</li>
<li>当JobImpl经过初始化后，开始调度内部的TaskImpl，如果任务处于<code>completedTasksFromPreviousRun</code>中，则向<code>TaskImpl</code>发送一个T_RECOVER事件，以恢复该任务之前的运行状态和信息，否则按照正常逻辑，发送一个<code>T_SCHEDULE</code>事件</li>
<li><code>TaskImpl</code>收到<code>T_RECOVER</code>事件后，通过上次运行信息恢复状态，即根据日志信息将状态直接转移到最终状态：<code>FAILED</code>、<code>KILLED</code>或者<code>SUCCEED</code></li>
</ul>
</li>
<li>当前MRAppMater仅能恢复上次已运行完成的任务，以避免重复运行，但对于正在运行的任务，则由RM强制杀死回收资源，造成大量浪费，更好的实现是把正在运行的任务直接划归到重启的MRAppMater中，但有一定复杂性，社区尚未考虑</li>
</ul>
</li>
</ol>
<h2 id="MR编程接口简述"><a href="#MR编程接口简述" class="headerlink" title="MR编程接口简述"></a>MR编程接口简述</h2><h3 id="InputFormat"><a href="#InputFormat" class="headerlink" title="InputFormat"></a>InputFormat</h3><ol>
<li><p>两个功能：</p>
<ul>
<li><p>数据切分：按照某个策略将输入数据切分成若干个split，以便确定MT个数以及对应的split，对应的函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;InputSplit&gt; <span class="title">getSplits</span><span class="params">(in context：JobContext)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为Mapper提供输入数据：给定某个split，Mapper将其解析成一个个key/value对，对应的函数：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RecordReader&lt;KEYIN,VALUEIN&gt;  <span class="title">createRecordReader</span><span class="params">(in split：InputSplit, in context：TaskAttemptContext)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p><img src="http://cevxd.img48.wal8.com/img48/542077_20160404152451/146936512078.png" alt="image"></p>
<ol>
<li>如上图所示，所有基于文件的基类都是FileInputFormat，由公共基类统一对各种输入文件进行切分，即第一个功能，然后由各个派生类自己提供机制进一步解析InputSplit，即第二个功能</li>
<li><p>举例说明：对于TextInputFormat，每一行内容即为value，该行在整个文件中的偏移量即为key，对应为Mapper中map()方法参数中的<code>key/value</code>，所以实现的map()方法，即可将value视为文件中的一行进行进一步数据处理</p>
<h3 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">map</span><span class="params">(in key, in value, in context：Mapper.Context)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>MR框架会通过InputFormat获取一个个key/value，然后交给map()方法处理；</p>
</li>
<li>map()方法处理的还是文件中的原始数据，主要工作是从输入数据提取目标数据，然后以key/value的形式输出到磁盘，等待reduce处理</li>
</ol>
<h3 id="Partitioner"><a href="#Partitioner" class="headerlink" title="Partitioner"></a>Partitioner</h3><p>作用是对map结果进行分片，以便将同一分片的数据交给同一个Reducer处理，直接影响Reduce阶段的负载均衡，对应的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPartition</span><span class="params">(in key：KEY，in value：VALUE，in numPartitions：<span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="Reducer："><a href="#Reducer：" class="headerlink" title="Reducer："></a>Reducer：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reduce</span><span class="params">(in key：KEYIN, in values：Iterable&lt;VALUEIN&gt;, in context：Reducer.Context)</span></span></span><br></pre></td></tr></table></figure>
<p>可以看到，reduce的输入，value是一个集合，即Map阶段产生的<code>K,V</code>对中，所有key相同的value集合，进行归约处理。</p>
<h3 id="OutputFormat"><a href="#OutputFormat" class="headerlink" title="OutputFormat"></a>OutputFormat</h3><p>用于描述Reduce阶段输出数据的格式。</p>
<h2 id="Task运行过程"><a href="#Task运行过程" class="headerlink" title="Task运行过程"></a>Task运行过程</h2><p>当我们需要编写一个简单的MR作业时，只需实现<code>map()</code>和<code>reduce()</code>两个函数即可，一旦将作业提交到集群上后，Hadoop内部会将这两个函数封装到Map Task和Reduce Task中，同时将它们调度到多个节点上并行执行，而任务执行过程中可能涉及的数据跨节点传输、记录按key分组等操作均由Task内部实现好了，用户无需关心。</p>
<h3 id="Map-Task内部实现"><a href="#Map-Task内部实现" class="headerlink" title="Map Task内部实现"></a>Map Task内部实现</h3><ol>
<li>整体流程：  <ul>
<li><code>Read阶段</code>：通过用户编写的RecordReader，从输入InputSplit中解析出以一个个key/value对</li>
<li><code>Map阶段</code>：将解析出的key/value对交给用户编写的map()函数处理，并产生一系列新的key/value对</li>
<li><code>Collect阶段</code>：在map()函数中，当数据处理完成后，一般会调用OutputCollector.collect()输出结果，在该函数内部，它会将生成的key/value对分片（通过调用Partitioner），并写入一个环形内存缓冲区中</li>
<li><code>Spill阶段</code>：即“溢出”，当环形缓冲区满后，MR会将数据写到本地磁盘上，生成一个临时文件，需要注意的是，将数据写入本地磁盘之前，先要对数据进行一次本地排序，并在必要时对数据进行合并、压缩等操作</li>
<li><code>Conbine阶段</code>：当所有数据处理完成后，MT对所有临时文件进行一次合并，确保最终只会生成一个数据文件</li>
</ul>
</li>
<li>Collect过程分析（详情请翻书）：  <ul>
<li>环形缓冲区，当缓冲区满了以后，可以读写并行，使得Collect阶段和Spill阶段并行进行</li>
<li>缓冲区内部使用两级索引结构，从缓冲区写入磁盘时，以及文件合并时，都在维护着该索引</li>
</ul>
</li>
<li>Spill过程分析：  <ul>
<li>步骤1：利用快排对缓冲区内的数据进行排序，排序方式是：先按照分区编号partition排序，然后按照key排序，经过排序后，数据以分区为单位聚集在一起，同一分区内所有数据按照Key有序</li>
<li>步骤2：按照分区编号从小到大依次将每个分区中的数据写入任务工作目录下的临时文件output/spillN.out中，如果用户设置了Combiner，则写入文件前，对每个分区中的数据进行一次聚集操作</li>
<li>步骤3：将分区数据的元信息写到内存索引数据结构中，其中每个分区的元信息包括在临时文件中的偏移量、压缩前数据大小和压缩后数据大小，输入内存中的索引大于1MB，则写到文件output/spillN.out.index中</li>
</ul>
</li>
<li>Combine过程分析：  <ul>
<li>在所有数据处理完后，MT会将所有临时文件合并成一个大文件，并保存到文件output/file.out 中，同时生成相应的索引文件output/file.out.index</li>
<li>在进行文件合并过程中，MT以分区为单位进行合并，对于某个分区，它将采用多轮递归合并的方式：每轮合并io.sort.factor（默认100）个文件，然后将合并后的文件重新加入待合并列表，重复直到最终得到一个大文件<h3 id="Reduce-Task内部实现"><a href="#Reduce-Task内部实现" class="headerlink" title="Reduce Task内部实现"></a>Reduce Task内部实现</h3></li>
</ul>
</li>
<li>整体流程：  <ul>
<li><code>Shuffle阶段</code>：也称为Copy阶段，RT从各个MT上远程拷贝一片数据，并针对某一片数据，如果其大小超过一定阈值，则写到磁盘，否则直接放到内存</li>
<li><code>Merge阶段</code>：在远程拷贝数据的同时，RT启动了两个后台线程对内存和磁盘上的文件进行合并，以防止内存使用过多或磁盘上文件过多</li>
<li><code>Sort阶段</code>：按照MR语义，为了在reduce之前，将key相同的数据聚在一起，RT对所有数据进行一次归并排序（因为MR排序，所以局部有序）</li>
<li><code>Reduce阶段</code>：将魅族数据依次交给用户编写的reduce()函数处理</li>
<li><code>Write阶段</code>：reduce()函数将计算结果写到HDFS上</li>
</ul>
</li>
<li>Shuffle和Merge阶段分析：<ul>
<li>两个阶段是并行进行的</li>
<li>可以分为三个子阶段：<ul>
<li>准备运行完成的MT列表：GetMapEventsThread周期性通过RPC后去已完成MT列表，并保存到映射表mapLocations中。为了防止出现网络热点，RT通过对所有host进行“混洗”以打乱拷贝顺序，并保存到scheduledCopies列表中</li>
<li>远程拷贝数据：RT同时启动多个MapOutputCopier线程，这些线程从scheduledCopies列表中获取MT输出位置，通过HTTP GET远程拷贝数据</li>
<li>合并内存文件和磁盘文件：为了防止内存或磁盘文件数据过多，RT启动了两个不同的线程分别对内存上和磁盘上的文件进行合并</li>
</ul>
</li>
<li>Sort和Reduce阶段分析：<ul>
<li>为了提高效率，RT将这两个阶段并行进行</li>
<li>在Sort阶段，RT为内存和磁盘中的文件建立了小顶堆，保存了指向堆根节点的迭代器，在Reduce阶段，RT不断地移动迭代器，以将key相同的数据顺次交给reduce()处理，启动迭代器的过程实际上就是不断调整小顶堆的过程，从而实现并行进行</li>
</ul>
</li>
</ul>
</li>
<li>用到的两个算法：<ul>
<li>快速排序，四个优化：<ul>
<li>中轴的选择：避免退化为O（N2），取序列收尾和中间元素中的中位数</li>
<li>子序列划分方法：两个索引，从两端交替扫描</li>
<li>对相同元素的优化：一次排序后划分为三部分：小于中轴、等于中轴、大于中轴，其中等于中轴的不再参与后续递归处理</li>
<li>减少递归次数：当子序列元素数目小于13时，直接使用插入排序法</li>
</ul>
</li>
<li>文件合并使用多轮合并方式：<ul>
<li>建小顶堆 </li>
<li>将堆顶指定数量（默认10）的文件进行合并</li>
<li>把合并后的文件加入堆尾，重新建堆</li>
<li>不断重复，直到合并成为一个大文件</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="MRAppMaster对Task的优化"><a href="#MRAppMaster对Task的优化" class="headerlink" title="MRAppMaster对Task的优化"></a>MRAppMaster对Task的优化</h3><ol>
<li>Map端：用Netty代替Jetty，提高RT数据读取请求的处理性能</li>
<li>Reduce端：批拷贝，原来是每个分片建立一个HTTP连接，即使在同一个TaskTracker上，现在是对于同一个TaskTracker上的多个MT建立同一个HTTP，一次读取多个分片</li>
<li>Reduce端：  <ul>
<li>Shuffle插件化：用户可以根据需要自定义实现，比如用RDMA代替HTTP</li>
<li>排序插件化：用户可以根据需求定制排序方法</li>
</ul>
</li>
</ol>
<h2 id="其他计算框架"><a href="#其他计算框架" class="headerlink" title="其他计算框架"></a>其他计算框架</h2><h3 id="DAG计算框架Tez"><a href="#DAG计算框架Tez" class="headerlink" title="DAG计算框架Tez"></a>DAG计算框架Tez</h3><ol>
<li>背景：在一些应用场景中，为了套用MR模型解决问题，不得不将问题分解成若干个有依赖关系的子问题，每个子问题对应一个MR作业，最终所有这些作业形成一个有向图（Directed Acyclic Graph，DAG）。在该DAG中，由于每个节点是一个MR作业，因此它们均会从HDFS上读一次数据和写一次数据（默认三份），即使中间节点的产生数据仅是临时数据，这种表达作业依赖关系的方式非常低效，而且浪费磁盘和网络IO资源</li>
<li>低效的根本原因：作业之间的数据不是直接流动的，而是借助HDFS作为共享数据存储系统通过多次读写进行转移的。更高效的方式应该是有依赖关系的前一个作业直接将产生的数据传输给依赖它的作业，省去中间的磁盘读写</li>
<li>Tez核心思想：将Map和Reduce两个操作进一步拆分，即Map拆分成Input、Processor、Sort、Merge和Output，Reduce拆分成Input、Shuffle、Sort、Merge、Processor和Output等，这些分解后的元操作可以灵活组合，产生新的操作，经过一些控制程序的组装后，可形成一个大的DAG作业</li>
<li>Tez特点：  <ul>
<li>运行在YARN之上，充分利用YARN的管理资源和容错等功能（由Hadoop 2.0核心人员打造）</li>
<li>提供了丰富的数据流API</li>
<li>扩展性良好的“Input-Processor-Output”运行时模型</li>
<li>动态生成物理数据流关系</li>
</ul>
</li>
<li>Tez适用场景：  <ul>
<li>数据挖掘和自然语言处理：<ul>
<li>用户既可以像适用MR一样，直接使用Tez编写DAG类型的应用程序</li>
<li>也可以把Tez作为MR之下的数据处理引擎，即用户依然使用MR编写程序，但使用Tez将之组装成一个DAG作业，Tez提供了一个MR到DAG的转换工具</li>
</ul>
</li>
<li>优化Pig、Hive等引擎<h3 id="实时计算框架Storm（Twitter开源的）"><a href="#实时计算框架Storm（Twitter开源的）" class="headerlink" title="实时计算框架Storm（Twitter开源的）"></a>实时计算框架Storm（Twitter开源的）</h3></li>
</ul>
</li>
<li>背景：MR因为以下几个特点，决定了它只适合离线批处理的应用场景：  <ul>
<li>启动时间长：一个MR作业由启动任务、Map任务、Reduce任务和清理任务四种组成，即使最简单的MR作业也会运行几秒到十几秒</li>
<li>调度开销大：当任务数目大时，全部调度完成耗时长，且资源不足时需排队等待</li>
<li>中间数据写磁盘：为了保证容错性，MT产生的中间结果总要写到磁盘，小作业延时大</li>
</ul>
</li>
<li>新的需求：实时计算和近实时计算相关的应用场景，比如广告推荐、用户行为日志实时分析、处理消息和更新数据库（消息流处理）</li>
<li>实时计算：是指被处理的数据像流水一样不断流入系统，而系统需要针对每条数据进行实时处理和计算，并永不停止（直到用户显式杀死进程），考虑到数据源中数据流动的特点，也称为“流式计算”</li>
<li>Storm和MR最大的不同：  <ul>
<li>Storm的数据源是动态的，即受到一条处理一条</li>
<li>MR的数据源是静态的，即数据被处理前整个数据集已经确定，且计算过程中不能被修改<h3 id="内存计算框架Spark（伯克利分校AMPLab实验室开发）"><a href="#内存计算框架Spark（伯克利分校AMPLab实验室开发）" class="headerlink" title="内存计算框架Spark（伯克利分校AMPLab实验室开发）"></a>内存计算框架Spark（伯克利分校AMPLab实验室开发）</h3></li>
</ul>
</li>
<li>背景：因为MR每次均需要从HDFS上读取数据进行处理，且不同计算之间只能通过HDFS重用数据，使其在以下一个应用场景中效率缓慢：  <ul>
<li>迭代计算：即相邻两轮计算要共享一部分数据，如果使用MR，只能通过HDFS读写共享，比如数据挖掘、机器学习、自然语言处理等领域的算法：PageRank、K-means聚类、逻辑回归等</li>
<li>交互式计算：在数据仓库应用中，在用户大量的查询语句中，有很多是作用在同一个数据集上的相同运算，即查询语句中的部分计算是相同的，但当使用Hive或Pig这样的系统时，它们每次都会重复计算，而不能重用计算结果，效率极低</li>
</ul>
</li>
<li>为了解决以上问题，Spark引入了弹性分布式数据集（RDD），它是一个有容错机制、可以被并行操作的数据集合，能够被缓存到内存中，共其他计算使用，而不必像MR那样每次都从HDFS上重新读取数据<h3 id="Storm和Spark比较"><a href="#Storm和Spark比较" class="headerlink" title="Storm和Spark比较"></a>Storm和Spark比较</h3>主要从运行的应用程序类型看：    </li>
<li>Storm通常是长作业，实际上是服务，永不终止，直到管理员显式杀死或服务故障</li>
<li>Spark通常是短作业，运行时间通常是分钟或者小时级别的</li>
</ol>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/从零爬Hadoop系列_4-《Hadoop技术内幕2》NodeManager/" itemprop="url">
                  从零爬Hadoop系列_4-《Hadoop技术内幕2》NodeManager
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-24T19:33:27+08:00" content="2016-07-24">
              2016-07-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Hadoop/" itemprop="url" rel="index">
                    <span itemprop="name">Hadoop</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/从零爬Hadoop系列_4-《Hadoop技术内幕2》NodeManager/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="从零爬Hadoop系列_4-《Hadoop技术内幕2》NodeManager/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="NM剖析"><a href="#NM剖析" class="headerlink" title="NM剖析"></a>NM剖析</h1><p>NM是YARN中单个节点上的代理，负责管理Hadoop集群中单个计算节点。和RM剖析一样，我们可以先从最开始的YARN的工作流程中观察，NM都需要和哪些组件进行交互，分别需要完成什么功能，则在NM内部，便会细分出来各个功能类别的模块，在每个模块内部，还可以继续按照功能细分，落实到各个组成的类或接口。</p>
<h2 id="NM基本职能"><a href="#NM基本职能" class="headerlink" title="NM基本职能"></a>NM基本职能</h2><ol>
<li>NM作为RPC的client端，周期性的主动向RM发起请求，这些请求包括向RM注册、汇报节点健康状况和节点上所有Container运行状态；并以请求应答的形式，领取RM下达的命令</li>
<li>NM作为RPC的server端，接收并处理AM下达的命令，这些命令包括启动Container、杀死Container、获取Container执行状态等，并返回执行结果</li>
<li>个人理解：其实以上两点都是NM作为整体对外负责的功能，而且并不是它最主要的功能，不要忘了，所有计算任务都是以Container的形式运行在NM上，所以NM最主要的功能是内部Container的管理，比如：  <ul>
<li>既然要运行任务，就需要下载任务运行所需的资源，每个NM上有很多Container，需要考虑并行下载和文件管理问题</li>
<li>资源下载完以后，还要监控各个Container的运行状态，进行日志记录</li>
<li>Container运行完成以后，还要进行之前下载资源的清理</li>
</ul>
</li>
</ol>
<h2 id="NM内部架构"><a href="#NM内部架构" class="headerlink" title="NM内部架构"></a>NM内部架构</h2><p>通过对YARN工作流程和NM职能的分析，可以猜测NM至少包含一下模块：</p>
<ol>
<li>AM管理模块：每个NM上可以运行多个AM，需要有对应的管理模块负责信息归总和管理</li>
<li>Container管理模块：每个NM上可以运行多个Container，且可以属于不同的AM，需要有对应的管理模块负责信息归总和管理  </li>
</ol>
<p>同时和RM一样，NM内部各个组件也是基于事件驱动的，NM内部架构组成如下：  </p>
<ol>
<li>NodeStatusUpdater：是NM和RM通信的唯一通道，对应职能1</li>
<li>ContainerManager：是NM中最核心组件之一，有一下组件：  <ul>
<li>RPC Servier：是AM和NM通信的唯一通道，对应职能2</li>
<li>ResourceLocalizationService：负责Container运行所需资源的本地化，即从HDFS上下载，同时尽量分摊到各个磁盘上，避免访问热点，同时添加访问权限</li>
<li>ContainersLauncher：维护了一个线程池并行完成Container相关的操作，比如启动或杀死Container，其中启动的命令来自AM，杀死的命令来自AM或RM（资源抢占时）</li>
<li>AuxServices：NM允许用户以附属服务的方式扩展自己的功能</li>
<li>ContainerMonitor：负责监控Container的资源使用量，防止超过RM分配的量，在YARN中，只有内存是通过它监控的</li>
<li>LogHandler：可插拔式组件，用户通过它控制Container日志保存方式：写到本地磁盘或上传到一个文件系统中</li>
<li>ContainerEventDispatcher：Container事件调度器，负责将ContainerEvent类型的事件调度给对应的Container的状态机ContainerImpl</li>
<li>ApplicationEventDispatcher：Application事件调度器，负责将ApplicationEvent类型的事件调度给对应的Application的状态机ApplicationImpl</li>
</ul>
</li>
<li>NodeHealthCheckerService：周期性运行自定义脚本和向磁盘写文件，以检查节点健康状况，然后通过NodeStatusUpdater汇报给RM，若发现不健康RM会将其加入黑名单，不再分配，直到其转为健康状态</li>
<li>DeletionService：负责删除Container运行完成后遗留的无用的资源文件或临时输出文件，为了避免同步删除文件带来的开销，NM将删除文件功能服务化，进行异步删除</li>
<li>Security：安全模块，主要两部分：  <ul>
<li>ApplicationACLsManager：确保访问NM的用户的合法性，比如Web UI访问，该组件为每个应用程序维护了一个ACL列表</li>
<li>ContainerTokenSecretManager：检查收到的各种访问请求的合法性，确保这些请求操作已被RM授权</li>
</ul>
</li>
<li>WebServer：通过Web界面展示该节点上所有应用程序运行状态、健康状况、日志等信息<br><img src="http://cevxd.img48.wal8.com/img48/542077_20160404152451/146936491468.png" alt="image"></li>
</ol>
<h2 id="健康节点状况监测"><a href="#健康节点状况监测" class="headerlink" title="健康节点状况监测"></a>健康节点状况监测</h2><ol>
<li>自定义Shell脚本：  <ul>
<li>NodeHealthScriptRunner服务周期性的执行监测脚本并检查其输出，如果标准输出打印出以字符串“ERROR”开头的语句，则认为节点不健康，通过心跳告诉RM</li>
<li>自定义脚本的好处：  <ul>
<li>可作为节点负载的反馈：因为当前YARN只对CPU和内存资源进行分配和隔离，所以用户可以通过自定义脚本检查网络、磁盘、文件系统等运行状况缓解这个问题</li>
<li>认为暂时维护NM：可以通过脚本输出ERROR停止NM接受新任务比便进行维护</li>
</ul>
</li>
</ul>
</li>
<li>检测磁盘损坏数目：  <ul>
<li>另外一种健康检测机制，默认开启，即与脚本检测同时进行，双重检查</li>
<li>检测方法：如果一个目录具有rwx权限，则认为它是正常的，否则加入坏磁盘列表，当比例过低时，便认为NM不健康，通过心跳告诉RM</li>
</ul>
</li>
</ol>
<h2 id="分布式缓存机制"><a href="#分布式缓存机制" class="headerlink" title="分布式缓存机制"></a>分布式缓存机制</h2><ol>
<li>主要作用：将用户应用程序执行时需要的外部文件资源自动透明地下载并缓存到各个节点上，省去用户手动部署。同时NM并不是一下子把所有资源下载下来，而是根据启动的Container按需下载，而且采用一定的缓存置换算法定期清理失效文件（默认10分钟）</li>
<li>工作流程：  <ul>
<li>步骤1：客户端将应用程序所需的文件资源提交到HDFS上</li>
<li>步骤2：客户端将应用程序提交到RM上</li>
<li>步骤3：RM与某个NM通信，让NM启动对应的AM，NM收到命令后，首先从HDFS下载文件（缓存），然后再启动AM</li>
<li>步骤4：AM与RM通信，以请求和获取Container</li>
<li>步骤5：AM收到新分配的Container后，与对应的NM通信，启动任务</li>
<li>步骤6：如果该应用程序第一次在该节点上启动任务，NM首先从HDFS上下载文件缓存到本地，然后启动任务</li>
<li>步骤7：NM后续收到启动任务请求后，如果有缓存，则直接启动，否则先等缓存成功再启动</li>
</ul>
</li>
<li>资源可见性（三种）：  <ul>
<li>PUBLIC：节点上所有用户共享，即只要存在，其他用户不用再下载</li>
<li>PRIVATE：节点上同一用户的所有应用程序共享</li>
<li>APPLICATION：节点上同一应用程序的所有Container共享</li>
</ul>
</li>
<li>资源分类（三类）：  <ul>
<li>ARCHIVE：归档文件，当前支持.jar、.zip、.tar.gz、.tgz、和.tar5种，NM可以自动解压缩</li>
<li>FILE：普通文件，NM只下载，没有额外处理</li>
<li>PATTERN：以上两种类型的混合体，用户需要通过正则表达式指定哪些属于ARCHIVE需要自动解压</li>
</ul>
</li>
<li>YARN分布式缓存的实现<ul>
<li>三种可见性资源分别放置在不同的目录下，通过目录权限实现不同的可见性</li>
<li>PUBLIC资源下载：由公共服务ResourceLocalizationService中的一个公用线程PublicLocalizer下载，它内部维护了个线程池并行下载</li>
<li>PRIVATE和APPLICATION：由公共服务ResourceLocalizationService中的一个专门线程下载：一个Container对应一个LocalizerRunner线程</li>
</ul>
</li>
</ol>
<h2 id="目录结构管理"><a href="#目录结构管理" class="headerlink" title="目录结构管理"></a>目录结构管理</h2><ol>
<li>由于同一个NM上不同的Container往往并行向本地磁盘写数据，为了避免占用大量IO资源造成相互干扰，尽量提高写数据的可靠性和并发写性能，YARN允许NM配置多个挂在不同磁盘的目录作为中间结果存放目录，对于任意一个应用程序，YARN会在每个磁盘中创建相同的目录结构，然后采用轮询策略使用这些目录<br><img src="http://cevxd.img48.wal8.com/img48/542077_20160404152451/146936491521.png" alt="image"></li>
<li>目录分类：  <ul>
<li>数据目录：存放Container运行所需和中间数据</li>
<li>日志目录：运行时输出的日志</li>
</ul>
</li>
<li>日志清理机制：  <ul>
<li>定期删除（默认）：默认3小时，超时删除</li>
<li>日志聚集转存：把日志上传到HDFS上，上传后删除，可以指定三种可以转存的类型（顾名思义）：  <ul>
<li>ALL_CONTAINER</li>
<li>APPLICATION_MASTER_ONLY</li>
<li>AM_AND_FAILED_CONTAINER_ONLY</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="状态机管理"><a href="#状态机管理" class="headerlink" title="状态机管理"></a>状态机管理</h2><ol>
<li>三类状态机：  <ul>
<li>Application状态机：维护的信息是RM端维护的子集，方便对一个节点上同一个应用程序的所有Container进行统一管理</li>
<li>Container状态机：维护一个Container的生命周期，三个阶段：  <ul>
<li>资源本地化</li>
<li>Container启动</li>
<li>资源清理（资源本地化逆过程，这里的资源指临时文件，而非硬件资源）：  <ul>
<li>这一步的清理，只是Container的临时数据，如Tokens文件和Shell运行脚本等</li>
<li>因为各个Container之间可能有依赖关系，所以NM规定只有在一个应用程序的所有Container全部结束以后，由RM发送广播，NM才能清理程序所占的所有资源和中间数据</li>
</ul>
</li>
<li>可以翻书了解详细的过程，进一步理解基于事件驱动的应用</li>
</ul>
</li>
<li>LocalizedResource状态机：维护一种资源的生命周期，从初始化、到下载中、到下载完成/下载失败</li>
</ul>
</li>
<li>个人理解：三类状态机的关系：从大流程上来看，基本可以认为是以下关系：  <ul>
<li>NM启动一个AM，创建对应的Application状态机</li>
<li>Application状态机在收到AM发送的启动Container请求后，会创建对应的Container状态机（一个或多个）</li>
<li>Container运行之前，需要先下载缺少的资源，即会创建对应的LocalizedResource状态机（一个或多个）进行资源下载，并等待所有资源下载完，然后进入运行状态</li>
</ul>
</li>
</ol>
<h2 id="资源隔离"><a href="#资源隔离" class="headerlink" title="资源隔离"></a>资源隔离</h2><ol>
<li>内存资源隔离：基于线程监控：  <ul>
<li>由服务ContainersMonitorImpl实现，它保存了每个Container进程pid，内部的MonitoringThread每隔一段时间（默认3000ms）扫描所有正在运行的Container进程树</li>
<li>步骤：  <ul>
<li>读取/proc/<pid>/stat文件构造进程树</pid></li>
<li>判断单个任务内存使用量是否超过最大值内存量</li>
</ul>
</li>
<li>由于JVM创建一个子进程时，采用了“fork()+exec()”模型，意味着进程创建之后、执行之前会复制一份父进程内存空间，进而使得进程数在某一小段时间内存使用量翻倍，为了防止误杀，Hadoop赋予每个进程“年龄”属性，并规定刚启动的进程年龄为1，MonitoringThread线程每更新一次，各个进程年龄加1，则内存超量使用而被杀死的判断标准为：  <ul>
<li>如果一个Container对应的进程树中所有进程（年龄大于0）总内存超过用户设定最大值的两倍</li>
<li>或者所有年龄大于1的进程总内存量超过用户设定的最大值</li>
<li>只要满足其一，则向对应的Container发送ContainerEventType.CKILL_CONTAINER事件将其杀死</li>
</ul>
</li>
<li>个人理解：内存隔离并不是真正的物理上的隔离，其他内存还是可见的，只是简单的一个线程监控使用量而已，所以需要用户在设定内存最大值时有良好的预估和分配</li>
</ul>
</li>
<li>CPU资源隔离：使用Cgroups（Control  groups）<ul>
<li>Cgroups是Linux内核提供的一种可以限制、记录、隔离进程组所使用的物理资源的机制，YARN通过使用其子系统CPU实现CPU资源隔离，该子系统使用调度程序控制任务对CPU的访问</li>
<li>Cgroups相比于虚拟机，是一种轻量级资源隔离方案</li>
<li>Cgroups只能保证应用程序的CPU使用下限，但不能限制上限。举例说明，某个节点上有10个虚拟CPU：  <ul>
<li>若该节点上只有一个应用程序A，且设定的CPU需求为4，则A最多能够使用全部CPU</li>
<li>若该节点上有两个应用程序A和B，且CPU需求都为4，则A和B都最多能够使用全部CPU，最少使用一半</li>
<li>若该节点上有三个应用程序A、B、C，CPU需求依次为4、4、2，则它们最多均可以使用全部CPU，最少可使用CPU资源比例依次为：4/(4+4+2)<em>10=40%、4/(4+4+2)</em>10=40%、2/(4+4+2)*10=20%</li>
</ul>
</li>
<li>NM默认没有启用任何CPU资源隔离机制</li>
<li>个人理解：CPU隔离也不是真正的物理上的隔离，而且按照上边的说明，基本可以说没有隔离，只能保证下限而已，同样需要用户对资源的使用量有良好的分配和设定</li>
</ul>
</li>
<li>所以总的来讲，所谓的资源隔离是比较虚的，不能顾名思义</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>对NM的理解：作为资源管理系统YARN的一个重要服务，NM管理的是Container，而不是任务，一个Container中可能运行着各种任务，但是对NM而言是透明的，它只负责Container相关的操作，比如管理Container的生命周期等。这也是YARN能够作为一个通用的资源管理平台的重要原因，它不管具体的任务类型或内容，只要按它规定的规范进行封装就可以提交运行</li>
<li>对Container的理解：Container从头到尾都只是一个逻辑抽象概念,RM把资源抽象为Container发送给AM，AM再发给NM，NM则会在Container描述的运行环境中启动任务，其实就是启动一个进程，然后在该进程下跑任务和各个状态机</li>
</ol>
<h2 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h2><ol>
<li>第一天的疑问1：怎么保证AM没有撒谎？比如AM并没有向RM申请资源，绕过RM直接通知NM启动任务？<ul>
<li>就是由Secret模块下的ContainerTokenSecretManager通过Token检查保证的</li>
</ul>
</li>
<li>第一天疑问2：YARN的工作流程第6步，为什么运行脚本而不是直接运行命令？<ul>
<li>因为直接执行命令可能让一些特殊符号发生转义</li>
</ul>
</li>
<li>第二天的疑问3：Container只是对资源逻辑上的划分和规定，在实际使用中，如何保证严格的物理划分或隔离？<ul>
<li>没有严格的物理划分或隔离，对于内存是监控上限，对于CPU是保证下限</li>
</ul>
</li>
<li>本章只介绍了节点的健康检测，那NM向RM心跳时汇报的所有Container的运行状态都包括哪些呢？又是怎么汇总的？</li>
<li>根据YARN工作流程的第七步的描述，听起来应该是各个Container心跳式的主动向AM汇报运行状态，但按照基本职能2的描述，只有一个AM主动查询运行状态的接口，那主动汇报的接口呢？本章好像没有提。</li>
</ol>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/从零爬Hadoop系列_3-《Hadoop技术内幕2》RM-资源调度器/" itemprop="url">
                  从零爬Hadoop系列_3-《Hadoop技术内幕2》RM-资源调度器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-24T19:14:00+08:00" content="2016-07-24">
              2016-07-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Hadoop/" itemprop="url" rel="index">
                    <span itemprop="name">Hadoop</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/从零爬Hadoop系列_3-《Hadoop技术内幕2》RM-资源调度器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="从零爬Hadoop系列_3-《Hadoop技术内幕2》RM-资源调度器/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="资源调度器"><a href="#资源调度器" class="headerlink" title="资源调度器"></a>资源调度器</h1><p>资源调度器对应昨天总结的RM中的资源调度模块，它是RM中一个插拔式的服务组件，对于资源调度器的理解，可以从两个角度出发：  </p>
<ol>
<li>资源：从资源角度出发，资源调度器负责管理NM向RM反馈的资源情况，并根据一定策略合理的进行资源分配</li>
<li>任务：从任务即应用程序出发，资源调度器负责从任务队列中，根据一定策略挑选出合适的任务分配给它资源，让它运行  </li>
</ol>
<h2 id="MRv1中的资源调度器"><a href="#MRv1中的资源调度器" class="headerlink" title="MRv1中的资源调度器"></a>MRv1中的资源调度器</h2><p>单队列FIFO调度机制，适用于批处理场景，面对的发展背景：随着Hadoop的普及，单个Hadoop集群上的用户量和应用程序种类不断增加。</p>
<ol>
<li>FIFO的缺点：<ul>
<li>不同应用程序对硬件资源需求侧重不同，FIFO不能充分利用集群资源</li>
<li>不同用户对应用程序的服务质量要求（QoS：Quality of Service）不同，FIFO不能满足多样化的需求：<pre><code>* 批处理作业：耗时长，对反应时间没有严格要求，如数据挖掘、机器学习
* 交互式作业：要求及时性，如SQL查询（Hive）
* 生产性作业：要求有一定量的资源保证，如统计值计算、垃圾数据分析等
</code></pre></li>
</ul>
</li>
<li>新的需求：适用于多用户的资源调度器，能够根据不同用户需求或不用应用程序的QoS针对性地进行资源分配和调度，充分利用集群资源</li>
<li>多用户资源调度器设计思路：  <ul>
<li>在一个物理集群上虚拟多个Hadoop集群，每个集群各自拥有全套独立的Hadoop服务，每个虚拟集群满足不同的需求，典型的代表是HOD：Hadoop On Demand</li>
<li>扩展YARN调度器，使之支持多个队列多用户，典型代表：<ul>
<li>Yahoo!的Capacity Scheduler</li>
<li>Facebook的Fair Scheduler</li>
</ul>
</li>
</ul>
</li>
<li>HOD：主要依赖于一个资源管理器（Torque）为它分配、回收节点和管理各个节点上的作业运行情况，HOD只需在资源管理器分配的节点上运行Hadoop守护进程和MR作业即可，HOD只在Hadoop 1.0中提供，Hadoop 2.0不再提供，这里也不再详述，主要缺陷如下：<ul>
<li>多个虚拟集群不方便管理</li>
<li>多个独立的虚拟集群不能共享资源，利用率低下</li>
<li>虚拟集群通常使用一个外部全局共享的HDFS，即丧失了数据本地特性</li>
</ul>
</li>
</ol>
<h2 id="YARN资源调度器"><a href="#YARN资源调度器" class="headerlink" title="YARN资源调度器"></a>YARN资源调度器</h2><h3 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h3><ol>
<li>YARN自带三种常用资源调度器，而且是插拔式的，用户可以按照接口规范自定义实现自己的：<ul>
<li>FIFO</li>
<li>Capacity Scheduler</li>
<li>Fair Scheduler</li>
</ul>
</li>
<li><p>YARN的资源调度器本质上是一个事件处理器，共需要处理来自外部的6种事件类型，并做不同的相应处理，其中NODE_UPDATE是最重要的事件，它会触发资源调度器最核心的资源分配机制；如下图：<br><img src="http://cevxd.img48.wal8.com/img48/542077_20160404152451/146936469148.png" alt="[图片]"></p>
</li>
<li><p>资源表示模型：</p>
<ul>
<li>抽象为Container，目前仅支持虚拟CPU和物理内存</li>
<li>其中CPU参数是虚拟的，比如机器A有16个CPU，机器B有8个CPU，而且每个CPU的性能都是机器A的一倍，则两者CPU的配置参数可以都是16或100等</li>
<li>两者参数都有取整参数配置，比如CPU默认取整单位为1，即CPU需求3.5，即取为4</li>
</ul>
</li>
<li>资源调度模型：<ul>
<li>双层资源调度模型：<ul>
<li>第一层：RM中的Scheduler将资源分配给各个AM，资源调度器主要关注这一层；</li>
<li>第二层：AM进一步将资源分配给它内部的各个任务，该层完全由用户应用程序决定；</li>
</ul>
</li>
<li>资源分配过程：<ul>
<li>分配过程是异步的，分为两个阶段：  <ol>
<li>AM周期性地心跳，请求资源并获取已经分配到的资源（不是当次请求的，而是之前的）；</li>
<li>NM向RM汇报各个Container运行状态，如果RM发现有空闲的，则进行一次资源分配，并将分配的资源保存到对应的应用程序数据结构中，等待下次AM发送心跳信息时取走（即阶段1）；</li>
</ol>
</li>
<li>详细步骤：<ol>
<li>NM通过周期性心跳汇报节点信息</li>
<li>RM为NM返回一个心跳应答，包括需要释放的Container列表等信息</li>
<li>RM收到来自NM的信息后，会触发一个NODE_UPDATE事件</li>
<li>RecourceScheduler收到NODE_UPDATE事件后，会按照一定的策略将该节点上的空闲资源（步骤2中有释放的资源）分配各应用程序，并将分配结果放到一个内存数据结构中，等待AM下次心跳时领取</li>
<li>AM向RM发送周期性的心跳，汇报资源需求，并领取已经分配到的Container</li>
<li>RM收到来自AM心跳信息后，把新的资源需求更新到对应的数据结构中，并返回为它分配的Container</li>
<li>AM收到新分配的Container列表后，会将这些Container进一步分配给它内部的各个任务</li>
</ol>
</li>
</ul>
</li>
<li>资源保证机制：<ul>
<li>增量资源分配（YARN采用的）：缺点是预留资源会导致资源浪费，利用率降低</li>
<li>一次性资源分配：缺点是会产生饿死现象</li>
</ul>
</li>
<li>资源分配算法：<ul>
<li>主资源公平调度算法（Dominant Resource Fairness，DRF），适用于多资源和复杂需求的环境，主要思想是把多维度资源调度问题转化为单资源调度问题，比例大的资源即为主资源，然后把资源分配给主资源所需份额最小的</li>
<li>最大最小公平算法（max-min fairness）：优点是小作业可以快速获取资源并完成</li>
</ul>
</li>
<li>资源抢占模型：<ul>
<li>资源抢占：在资源调度器中，每个队列可设置一个最小资源量和最大资源量，作用顾名思义，但最小资源量并不是绝对的底线，当某个队列不需要任何资源时，会将空闲资源暂时借给其他需要的队列使用，所谓的抢占就是：当某个把资源借出去的队列突然收到提交的应用程序急需资源时，就需要把借出去的资源抢占回来，采用的策略是先等待再强制抢占</li>
<li>大致步骤：<ol>
<li>SchedulingEditPolicy探测到需要抢占的资源，将需要抢占的资源通过事件DROP_RESERVATION和PREEMPT_CONTAINER发送给RM</li>
<li>RM调用ResourceScheduler的dropContainerReservation和preemptContainer函数，标注待抢占的Container</li>
<li>RM收到来自AM的心跳，并通过应答的形式把待释放的资源总量和待抢占的Container列表返回给它，AM收到列表后，可以选择如下操作：  <ul>
<li>杀死这些Container</li>
<li>选择并杀死其他Container凑够数量</li>
<li>不做任何处理，过段时间可能有Container自行释放或被RM杀死</li>
</ul>
</li>
<li>SchedulingEditPolicy探测到一段时间内，AM为自行杀死约定的Container，则将这些Container封装到KILL_CONTAINER事件中发送给RM</li>
<li>RM收到后调用ResourceScheduler的killContainer函数，标注这些待杀死的Container</li>
<li>RM收到来自NM的心跳，并以应答的形式把待杀死的Container列表返回给它，NM收到后，将这些Container杀死，并通过心跳告知RM</li>
<li>RM收到来自AM的心跳，并通过应答的形式把已经杀死的Container列表发送给它（可能AM早已通过内部通信机制知道了）</li>
</ol>
</li>
<li>需要考虑的问题：<ul>
<li>资源抢占，并不是简单的把借出去的原原本本的抢回来，而是通过一定的计算，来决定抢占哪些队列的资源（大致是抢占这种队列：资源使用量超过了参数设定的本应使用的量）</li>
<li>如何使资源抢占代价最小：<ul>
<li>YARN优先选择优先级低的Container</li>
<li>并没有直接杀死，而是先告知AM自行处理，此时AM可以做一些进度保存等</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="层级队列管理机制："><a href="#层级队列管理机制：" class="headerlink" title="层级队列管理机制："></a>层级队列管理机制：</h3><p>YARN以树状层次的结构组织多个队列，其中用户只能把应用程序提交到最底层的叶子队列，非叶子队列的属性即下边所有叶子队列的属性和。<br><img src="http://cevxd.img48.wal8.com/img48/542077_20160404152451/146936469103.png" alt="image"></p>
<ol>
<li>特点：<ul>
<li>子队列；</li>
<li>最小容量：<ul>
<li>每个子队列都有一个最少容量比，表示可以使用父队列的容量的百分比</li>
<li>调度器总是优先把资源分配给资源使用率最低的队列，比如队列Q1和Q2的最小容量分别是10和20，当前两个队列以使用的资源都是5，则优先分配给Q2</li>
<li>如上所述，不是绝对的底线，可以借出使用</li>
</ul>
</li>
<li>最大容量</li>
</ul>
</li>
<li>队列管理机制：<ul>
<li>用户权限管理：基础OS用户管理之上，增加了“队列”这一用户组织单元，同一用户或用户组可以对应一个或多个队列</li>
<li>系统资源管理：管理员设置每个队列的资源容量信息，调度器按照约束进行调度</li>
</ul>
</li>
<li>命名规则：ROOT.A.A1，避免重名</li>
</ol>
<h3 id="Capacity-Scheduler和Fair-Scheduler"><a href="#Capacity-Scheduler和Fair-Scheduler" class="headerlink" title="Capacity Scheduler和Fair Scheduler"></a>Capacity Scheduler和Fair Scheduler</h3><ol>
<li>Capacity Scheduler特点：  <ul>
<li>容量保证：可以设定上下限，同一队列的应用程序共享队列资源</li>
<li>灵活性：空闲资源可以外借出去和抢占回来，利用率高</li>
<li>多重租赁：管理员可以按用户或按应用程序类别分不同的队列，并给不同队列设定多重约束，支持多用户共享集群和多应用程序同时运行</li>
<li>安全保证：  <ul>
<li>每个队列有严格的ACL列表控制访问用户</li>
<li>每个用户可指定哪些用户可以查看或控制自己的应用程序</li>
<li>管理员可指定队列管理员或集群管理员</li>
</ul>
</li>
<li>动态更新配置文件：动态修改各种配置参数，支持在线集群管理</li>
</ul>
</li>
<li>Fair Scheduler特点：  <ul>
<li>资源公平共享：在每个队列内部，选择应用程序时默认采用Fair策略，即队列中n个应用程序，每个应用程序可以得到1/n的资源</li>
<li>支持资源抢占：先等待再强制回收</li>
<li>负载均衡：用户除了可以自定义负载均衡机制，还可以使用默认的基于任务数目的均衡机制，尽可能将系统中的任务均匀的分配到各个节点上</li>
<li>调度策略配置灵活：管理员可以为每个队列单独设置调度策略：FIFO、Fair、DRF三种</li>
<li>提高小应用程序响应时间：即第一点提到的，Fair策略可以使小应用程序快速获取资源并运行完成</li>
</ul>
</li>
<li>两者比较：<ul>
<li>大体思路相同：  <ol>
<li>处理心跳信息：  <ul>
<li>第一类信息：最新启动的Container：资源调度器通知RM，将对应的Container从超时监控队列中删除</li>
<li>第二类信息：运行完成的Container：回收资源，进行分配</li>
</ul>
</li>
<li>资源分配：<ul>
<li>当NM有运行完成的资源上报时，RS将按照指定的调度策略，从层级队列的树根遍历，依次选择队列、应用程序、Container请求进行资源分配（调度结果可能是一个或多个Container请求），即所谓的三级资源分配策略</li>
</ul>
</li>
</ol>
</li>
<li>三级资源分配策略不同点：  <ol>
<li>队列选择（从树形层级结构中选择叶子队列）：  <ul>
<li>CS根据资源使用率（已使用资源量/队列资源容量）排序选择</li>
<li>FS按照指定策略排序选择（FIFO、Fair、DRF）</li>
</ul>
</li>
<li>应用程序选择（从叶子队列中选择APP）：  <ul>
<li>CS按照提交时间排序选择</li>
<li>FS默认按照Fair策略排序选择</li>
</ul>
</li>
<li>Container请求选择（同一个应用程序内部有多个子任务，对应多个资源请求）：<ul>
<li>CS按照优先级/本地性进行选择</li>
<li>FS同上</li>
</ul>
</li>
</ol>
</li>
<li>随着两者功能逐步完善，两者同质化严重，基本相同，但因为Fair Scheduler比Capacity Scheduler多了特点&lt;调度策略配置灵活&gt;，即每个队列有三种调度策略选择，所以可以说FS具备CS所有的功能</li>
</ul>
</li>
</ol>
<h2 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h2><ol>
<li>为什么采用层级队列组织方式，对“多用户多队列”的理解：<ul>
<li>从用户角度管理：因为不同用户，可能有不同的权限，对提交的应用程序的QoS要求不同，这时便可以把用户按照权限或QoS要求分类放置到不同的队列中进行分类管理</li>
<li>从应用程序角度管理：因为不同的应用程序有不同的特点和要求，对资源的需求也不同，这时便可以把应用程序按照特点或资源需求分类放置在不同的队列中分类管理（其实还是对用户分类，因为只能对队列设定可以提交任务的用户）</li>
<li>从资源的角度管理：如果是单队列，可能出现某个用户或某个应用程序霸占整个集群资源的情况，无法均衡地支持多用户多应用程序并行，这时便可以给不同的队列设定不同的资源上下限，进行资源分配管理，平衡地支持多用户多应用程序共享资源，并行运行</li>
</ul>
</li>
<li>前一篇的疑问：AM为任务申请到资源后，为什么由AM通知NM，而不是RM通知NM：<ul>
<li>双层资源调度模型：<ul>
<li>使RM集中关注各个AM的资源分配，分担压力，功能划分</li>
<li>下放资源分配的权限，AM内部资源分配由用户定义，灵活扩展</li>
</ul>
</li>
</ul>
</li>
<li>Container只是对资源逻辑上的划分和规定，在实际使用中，如何保证严格的物理划分或隔离？</li>
<li>用户提交的应用程序和应用程序提交的内部任务，使用的都是这种层级队列吗？同一个吗？</li>
<li>通过对两种调度器三级资源分配策略的分析，可以发现在选择Container请求时，好像并没有检查将要分配出去的Container是否满足请求中的需求量，是这样吗？</li>
</ol>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/从零爬Hadoop系列_2-《Hadoop技术内幕2》ResourceManager/" itemprop="url">
                  从零爬Hadoop系列_2-《Hadoop技术内幕2》ResourceManager
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-24T18:50:57+08:00" content="2016-07-24">
              2016-07-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Hadoop/" itemprop="url" rel="index">
                    <span itemprop="name">Hadoop</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/从零爬Hadoop系列_2-《Hadoop技术内幕2》ResourceManager/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="从零爬Hadoop系列_2-《Hadoop技术内幕2》ResourceManager/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="RM剖析"><a href="#RM剖析" class="headerlink" title="RM剖析"></a>RM剖析</h2><h3 id="内部架构"><a href="#内部架构" class="headerlink" title="内部架构"></a>内部架构</h3><p>从前边YARN的工作流程图中可以看到，RM作为一个处理中心，分别需要和Client、NM、AM交互做处理，那RM是怎么做到这些交互的呢？其实很简单，从面向对象的角度理解，RM作为一个综合的处理中心，是一个大部门，所以在RM内部，又按照服务类别细分了很多“专一”的模块，每个模块作为服务或事件调度器对外提供访问接口，所有这些访问接口组合起来才形成了上边工作流程图中的各种交互。其中每个模块内部还能继续功能细分，直到把单一功能落实到具体的类或接口中，总的内部架构图如下：<br><img src="http://cevxd.img48.wal8.com/img48/542077_20160404152451/146936452667.png" alt="image"></p>
<h3 id="模块简介："><a href="#模块简介：" class="headerlink" title="模块简介："></a>模块简介：</h3><ol>
<li>Client交互模块:<ul>
<li>ClientRMService：为普通用户提供服务，如提交应用、终止应用、获取应用运行状态等</li>
<li>AdminService：为管理员提供了一套独立的服务接口，防止大量普通用户请求使得管理命令饿死，如动态更新节点列表、更新ACL列表等</li>
<li>WebApp：Web界面，友好地展示集群资源使用情况和应用运行状态等信息</li>
</ul>
</li>
<li>NM管理模块：<ul>
<li>NMLivelinessMonitor：监控NM是否活着</li>
<li>NodesListManager：维护正常节点和异常节点列表</li>
<li>ResourceTrackerService：处理来自NM的请求，主要包括注册和心跳两种请求</li>
</ul>
</li>
<li>AM管理模块：<ul>
<li>AMLivelinessMonitor：监控AM是否活着</li>
<li>ApplicationMasterLauncher：与NM通信，要求它为某个应用启动AM</li>
<li>ApplicationMasterService：处理来自AM的请求，主要包括注册和心跳两种请求</li>
</ul>
</li>
<li>Application管理模块：<ul>
<li>ApplicationACLsManager：管理应用程序访问权限，查看权限和修改权限</li>
<li>RMAppManager：管理应用程序的启动（提交和后续对象的创建）和关闭</li>
<li>ContainerAllocationExpirer：AM没有在规定时间内在对应的NM上启动新分配的Container，则RM强制回收，是否回收由该类决定和执行</li>
</ul>
</li>
<li>状态机管理模块：状态机维护着有状态对象的生命周期，RM中共维护4类：<ul>
<li>RMApp：维护的是同一个Application启动的所有运行实例的生命周期，从启动到运行结束</li>
<li>RMAppAttempt：app运行实例的每次启动称为一次运行尝试，该类维护着一次运行尝试的生命周期，从启动到运行结束</li>
<li>RMContainer：维护一个Container的运行周期，从创建到运行结束</li>
<li>RMNode：维护一个NM的生命周期，从启动到运行结束</li>
</ul>
</li>
<li>安全管理模块：<ul>
<li>认证：同时采用Kerberos和Token两种技术，保证各个组件之间通信内容的合法性</li>
<li>授权：访问控制列表ACL</li>
</ul>
</li>
<li>资源分配模块：<ul>
<li>ResourceScheduler：<ul>
<li>批处理调度器：FIFO</li>
<li>多用户调度器<ul>
<li>Fair Scheduler</li>
<li>Capacity Scheduler<h3 id="容错机制："><a href="#容错机制：" class="headerlink" title="容错机制："></a>容错机制：</h3></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>AM容错：RM负责监控AM的运行状态，若运行失败或超时，会重新分配资源并重启它</li>
<li>NM容错：NM定时向RM发送心跳，若超时，则NM上的Container状态置为失败，并交由对应的AM处理其中的任务</li>
<li>Container容错：即前边提到的ContainerAllocationExpirer负责的超时未启动处理</li>
<li>RM容错：基于共享存储的HA解决方案，YARN采用基于Zookeeper的方案<ul>
<li>主备切换分为手动和自动</li>
<li>HA(High Availability)需要考虑的问题：<ul>
<li>脑裂：<ul>
<li>共享存储隔离：确保只有一个Master往共享存储中写数据</li>
<li>客户端隔离：确保只有一个Master可以响应客户端的请求</li>
<li>Slave隔离：确保只有一个Master可以向Slave下发命令</li>
</ul>
</li>
<li>切换对外透明：多次连接失败后换一个连接<h3 id="常见行为分析"><a href="#常见行为分析" class="headerlink" title="常见行为分析"></a>常见行为分析</h3>因为RM相当于YARN整个系统的核心，具备很多功能，每个功能都是基于事件在各个组成结构之间驱动的，所以并没有一个固定或统一的处理流程，只能针对某一个功能来说，比如：  </li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>启动AM</li>
<li>申请和分配Container</li>
<li>杀死AM</li>
<li>Container超时</li>
<li>AM超时</li>
<li>NM超时  </li>
</ul>
<p>流程复杂，这里不再详述，建议回去翻书，总之一定要结合几个常见行为的分析，从中理解：服务化、基于事件驱动、状态机这三者在其中的应用，以及相比之前的直接函数调用，这三者的优势和带来的改进。<br>RM中的重头：资源管理器，将在下篇博文详细介绍。</p>
<h2 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h2><p>想不通的不要急，后续了解多了自然就明白了(带着问题看书懂得更多)。</p>
<ol>
<li>YARN的工作流程第5步：<ul>
<li>为什么AM为任务申请到资源以后，不是RM通知对应的NM启动对应的Container？</li>
<li>怎么保证AM没有撒谎？比如AM并没有向RM申请资源，绕过RM直接通知NM启动任务？</li>
</ul>
</li>
<li>YARN的工作流程第6步，为什么运行脚本而不是直接运行命令？</li>
</ol>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/从零爬Hadoop系列_1-《Hadoop技术内幕2》基础篇/" itemprop="url">
                  从零爬Hadoop系列_1-《Hadoop技术内幕2》基础篇
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-24T18:36:15+08:00" content="2016-07-24">
              2016-07-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Hadoop/" itemprop="url" rel="index">
                    <span itemprop="name">Hadoop</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/从零爬Hadoop系列_1-《Hadoop技术内幕2》基础篇/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="从零爬Hadoop系列_1-《Hadoop技术内幕2》基础篇/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="MRv1到YARN"><a href="#MRv1到YARN" class="headerlink" title="MRv1到YARN"></a>MRv1到YARN</h2><ol>
<li>MRv1主要是以MR为主的计算框架，而MRv2主要是针对MRv1的缺陷改进而来的，以YARN为主的轻量级弹性计算平台；</li>
<li>MRv1的缺陷：<ul>
<li>扩展性差：JobTracker兼备资源管理和作业控制；</li>
<li>可靠性差：master单点故障；</li>
<li>资源利用率低：粗粒度的划分单位，任务之间不共享；</li>
<li>无法支持多种计算框架：只有基于磁盘的离线计算框架MR，不能满足多种需求；</li>
</ul>
</li>
<li>YARN的诞生背景：<ul>
<li>基于数据密集型应用的计算框架层出不穷：<ul>
<li>MR：离线处理；</li>
<li>Storm：在线处理；</li>
<li>Spark：迭代式处理；</li>
<li>S4：流式处理；</li>
</ul>
</li>
<li>各种框架各有所长，在同一个公司中，多种框架可能被同时采用，如网页建立索引用MR，自然语言处理/数据挖掘用Spark等，考虑到成本等，又希望把所有框架部署在一个共享集群中，而非各占一个独立集群，而且需要在对共享资源统一管理使用的同时，保证各个任务的隔离性，急需轻量级弹性计算平台。</li>
</ul>
</li>
<li>共享集群的好处：<ul>
<li>资源利用率高：多种框架共享资源，统一管理，不会出现分配不均或某些紧缺而某些空闲的问题；</li>
<li>运维成本低：管理员成本和硬件成本；</li>
<li>数据共享：减小数据移动带来的成本；</li>
</ul>
</li>
<li>一个框架一个集群 到 多个框架共享集群：<br><img src="http://cevxd.img48.wal8.com/img48/542077_20160404152451/146936452783.jpg" alt="[图片]"></li>
</ol>
<h2 id="YARN的组成结构和流程"><a href="#YARN的组成结构和流程" class="headerlink" title="YARN的组成结构和流程"></a>YARN的组成结构和流程</h2><ol>
<li>YARN基本组成结构：<ul>
<li>ResourceManager（RM）：全局资源管理器，负责资源管理和分配；<ul>
<li>Schduler：纯调度器，只负责根据各个应用程序的资源需求进行资源分配；</li>
<li>ApplicationManager（ASM）：负责管理整个系统中所有应用程序；</li>
</ul>
</li>
<li>ApplicationMaster（AM）：用户提交的每个应用程序均包含一个AM，主要功能：<ul>
<li>与Scheduler协商获取资源（Container）；</li>
<li>将得到的任务进一步分配给内部的任务；</li>
<li>与NM通信以启动/停止任务；</li>
<li>监控所有任务运行状态，并在任务运行失败时重新为任务申请资源以重启任务；</li>
</ul>
</li>
<li>NodeManager（NM）：每个节点上的资源和任务管理器，主要功能：<ul>
<li>定时向RM汇报本节点上的资源使用情况和各个Container的运行状态；</li>
<li>接受并处理来自AM的Container启动/停止等请求；</li>
</ul>
</li>
<li>Container：资源抽象，封装某个节点上的多维度资源，如内存、CPU、磁盘等</li>
</ul>
</li>
<li>YARN工作流程：<ul>
<li>步骤1：用户向YARN提交应用程序，其中包括AM程序、启动AM的命令、用户程序等；</li>
<li>步骤2：RM为该应用程序分配第一个Container，并与对应的NM通信，要求它在这个Container中启动该AM；</li>
<li>步骤3：AM首先向RM注册，这样用户可以通过RM查看应用程序的运行状态，然后它将为各个任务申请资源，并监控它们的运行状态，直到运行结束，即重复步骤4~7；</li>
<li>步骤4：AM采用轮询的方式，通过RPC协议向RM申请和领取资源；</li>
<li>步骤5：一旦AM申请到资源后，便与对应的NM通信，要求它启动任务；</li>
<li>步骤6：NM为任务设置好运行环境后，将任务启动命令写到一个脚本中，通过运行该脚本启动任务；</li>
<li>步骤7：各个任务通过某个RPC协议向AM汇报自己的状态和进度，以便AM随时掌握各个任务的运行状态，从而可以在任务失败时重启任务；</li>
<li>步骤9：应用程序运行完成后，AM向RM注销并关闭自己；</li>
<li>如下图：<br><img src="http://cevxd.img48.wal8.com/img48/542077_20160404152451/146936452735.png" alt="[图片]"></li>
</ul>
</li>
<li>YARN的理解角度：<ul>
<li>多线程并行编程：<ul>
<li>YARN：云操作系统，为应用程序启动AM；</li>
<li>AM：主线程，负责应用程序内部的数据切分、任务分配等，并启动各个Task；</li>
<li>Task：子线程，仅负责自己的计算任务，完成即结束退出；</li>
<li>当所有子线程（Task）结束以后，主线程（AM）结束退出；</li>
</ul>
</li>
<li>资源管理器；</li>
<li>云计算：YARN可以看做PAAS层，为不同类型的应用程序提供统一的管理和调度；</li>
</ul>
</li>
</ol>
<h2 id="YARN基础库"><a href="#YARN基础库" class="headerlink" title="YARN基础库"></a>YARN基础库</h2><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><ol>
<li>Hadoop RPC（集群各组件之间的通信方式）总体架构：<ul>
<li>序列化层：结构化对象转为字节流便于网络传输或持久存储，主要用于请求中的参数和应答跨机器传输；</li>
<li>函数调用层：定位要调用的函数并执行该函数，Hadoop RPC采用Java反射机制和动态代理实现；</li>
<li>网络传输层：描述了Client和Server之间消息传输的方式，Hadoop RPC采用基于TCP/IP的Socket机制；</li>
<li>服务器端处理框架：描述了Client和Server之间信息交互的方式，直接决定服务器端的并发处理能力，Hadoop RPC采用基于Reactor设计模式的事件驱动I/O模型；</li>
</ul>
</li>
<li>YARN RPC：可以集成多种RPC框架，如Protocol Buflers、Thrift、Avro等；</li>
<li>对RPC的理解和实现，可以通过查看具体的例子进行理解，比如NM的心跳函数；</li>
</ol>
<h3 id="服务库（使得YARN低耦合、高内聚、设计简单、易维护）"><a href="#服务库（使得YARN低耦合、高内聚、设计简单、易维护）" class="headerlink" title="服务库（使得YARN低耦合、高内聚、设计简单、易维护）"></a>服务库（使得YARN低耦合、高内聚、设计简单、易维护）</h3><ol>
<li>对于生命周期较长的对象，YARN采用了基于服务的对象管理模型对其进行管理，几个特点：<ul>
<li>每个被服务化的对象分为4个状态：NOTINITED、INITED、STARTED、STOPPED；</li>
<li>任何服务状态变化都可以触发另外一些动作；</li>
<li>可以通过组合的方式对任意服务进行组合，以便统一管理；</li>
</ul>
</li>
<li>在YARN中，RM和NM属于组合服务，它们内部包含多个单一服务和组合服务，以实现对内部多种服务的统一管理；</li>
</ol>
<h3 id="事件库（使得YARN低耦合、高内聚、设计简单、易维护）"><a href="#事件库（使得YARN低耦合、高内聚、设计简单、易维护）" class="headerlink" title="事件库（使得YARN低耦合、高内聚、设计简单、易维护）"></a>事件库（使得YARN低耦合、高内聚、设计简单、易维护）</h3><ol>
<li>为了构建基于事件驱动的并发模型，YARN将各种处理逻辑抽象成事件和对应的事件调度器，并把每类事件的处理过程分割成多个步骤，用有限状态机表示；</li>
<li>处理过程：<ul>
<li>处理请求作为事件进入系统；</li>
<li>由中央异步调度器负责传递给对应的事件调度器；</li>
<li>事件调度器有两种处理：<ul>
<li>可能将该事件转发给另外一个事件调度器；</li>
<li>也可能交给一个带有有限状态机的事件处理器，其处理结果也以事件的形式输出给中央异步调度器；</li>
</ul>
</li>
<li>新的事件会再次被中央异步调度器转发给下一个事件调度器，直至处理完成（到达终止条件）。</li>
</ul>
</li>
<li>在YARN中，所有核心服务实际上都是一个中央异步调度器，包括RM、NM、AM等，它们维护了事先注册的事件和事件处理器，并根据接收的事件类型驱动服务的运行；</li>
</ol>
<h3 id="状态机库（使得YARN设计架构更清晰）"><a href="#状态机库（使得YARN设计架构更清晰）" class="headerlink" title="状态机库（使得YARN设计架构更清晰）"></a>状态机库（使得YARN设计架构更清晰）</h3><ol>
<li>如上所述，在YARN中，事件的处理过程被分割成多个步骤，用有限状态机表示，换言之，有限状态机维护着有状态对象的生命周期；</li>
<li>在YARN中，每种状态转换由一个四元组表示，分别是转换前状态preState、转换后状态postState、事件event和回调函数hook，表示状态机在preState状态下，接收到事件event后，执行回调函数hook，并在执行完成后将状态转换为postState。</li>
<li>YARN定义了三种状态转换方式：<ul>
<li>一个初态、一个终态、一种事件；</li>
<li>一个初态、多个终态、一种事件，终态由hook返回值确定；</li>
<li>一个初态、一个终态、多种事件；</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/从零爬Hadoop系列_0-我听说的Hadoop/" itemprop="url">
                  从零爬Hadoop系列_0-我听说的Hadoop
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-23T14:54:29+08:00" content="2016-07-23">
              2016-07-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Hadoop/" itemprop="url" rel="index">
                    <span itemprop="name">Hadoop</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/从零爬Hadoop系列_0-我听说的Hadoop/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="从零爬Hadoop系列_0-我听说的Hadoop/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在两年前入学就听舍友说这些高大上的东西，然而两年过去了，前一段阿里面试问及依然一问三不知。最近在华为实习，有幸借此机会接触学习大数据，三周过去获益匪浅。不仅仅是学到了知识，而且还学到并深刻体会到学习能力和学习方法的重要性。从看书到写笔记，再把笔记串联起来整理成博文，不仅记录学习历程，方便以后回头复习，而且使自己理解得更透彻，而不是蒙混过关。所以我把最近学习的笔记，结合自己的理解整理成一系列博文，主要包括读书笔记、环境搭建、使用说明、以及一些源码理解，旨在二次理解、记录存档和分享。</p>
<h2 id="什么是Hadoop"><a href="#什么是Hadoop" class="headerlink" title="什么是Hadoop"></a>什么是Hadoop</h2><p>近几年大数据火得不行，平时我们可能多多少少会听到一些相关的东西，比如Hadoop、MapReduce、Spark什么的，但还真没仔细了解过都是些什么东西，有什么用。所以在开始学习之前，先来看一下我们要学的是什么。</p>
<blockquote>
<p><a href="http://hadoop.apache.org/" target="_blank" rel="external"><strong>What Is Apache Hadoop?</strong></a><br>The Apache™ Hadoop® project develops open-source software for reliable, scalable, distributed computing.<br>The Apache Hadoop software library is a framework that allows for the distributed processing of large data sets across clusters of computers using simple programming models. It is designed to scale up from single servers to thousands of machines, each offering local computation and storage. Rather than rely on hardware to deliver high-availability, the library itself is designed to detect and handle failures at the application layer, so delivering a highly-available service on top of a cluster of computers, each of which may be prone to failures.</p>
</blockquote>
<p>简单地总结一下就是借助Hadoop，我们可以很方便的把廉价普通的机器组成集群，然后通过简单的编程模型实现分布式地大数据计算处理，而且有容错机制保证高可靠性。不懂吗？接着往下看。</p>
<h2 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h2><p>Hadoop有很多版本，其中从Hadoop1升级到Hadoop2的变化最大。可以说，Hadoop1只是一个以MapReduce为主的计算框架，而Hadoop2则进化成一个以Yarn为主的弹性计算平台，侧重于集群的资源管理，同时可以集成包括MapReduce在内的众多计算框架。Hadoop2主要包括以下四个模块：</p>
<blockquote>
<p>The project includes these modules:<br><strong>Hadoop Common</strong>: The common utilities that support the other Hadoop modules.<br><strong>Hadoop Distributed File System (HDFS™)</strong>: A distributed file system that provides high-throughput access to application data.<br><strong>Hadoop YARN</strong>: A framework for job scheduling and cluster resource management.<br><strong>Hadoop MapReduce</strong>: A YARN-based system for parallel processing of large data sets.  </p>
</blockquote>
<p>如果你和我一样对大数据和Hadoop是个小白，那你可能需要先弄明白集群是怎么运作的。<br>什么是集群呢？其实很简单，通俗点讲，就是由一群机器组成的一个整体，而且这个整体和其他所有团体一样，拥有自己的内部架构，根据责任划分“部门”，自然也就有Boss和干活的小喽喽。Boss作为集群整体对外的任务承接人，拿到任务以后，再根据内部规则有条不紊地分配下发，具体到各个小喽喽都有自己的一小部分任务做，大家都完成以后整个任务也就完成了，人多力量大嘛。听起来是不是很像我们码农在公司搬砖一样呢？其实就是一样的，这种架构就是我们常听到的Master-Slave（你有没有觉得我们曾经学过的很多东西其实都不是什么新东西，都是从我们现实世界已有的概念和规则搬过去了而已，不过也不能说不是创新）。<br>现在我们再来解释一下上边四个组件的作用：</p>
<ol>
<li><strong>Hadoop Common</strong>：顾名思义，是一些公共的基础组件，主要包括RPC、事件库和状态机三部分。RPC是什么呢？Remote Process Call，远程过程调用，主要用于集群间各个机器通过网络进行通信的，是不是才反应过来？我们平时写代码顶多也就是线程通信、进程通信，那集群之间当然是网络通信了。至于事件库和状态机，可以先不细究，只用记着它们两个让整个集群的并发量上了天就可以了。  </li>
<li><strong>HDFS</strong>：一个分布式文件系统，什么用呢？文件系统可以理解吧？存储在硬盘上的二进制数据，就是靠文件系统变成了一个个有组织的、方便操作的文件。那对于集群才说，当然需要一个分布式的文件系统，把整个集群的所有硬盘数据当成一个整体来管理使用了。怎么做到的？当然也是靠Master-Slave啦。</li>
<li><strong>YARN</strong>：这个是Hadoop2中最重要的角色，后续的读书笔记也主要是讲它的。前边说可以很方便的把廉价机器组成集群，通过简单的编程模型就能够实现分布式大数据处理，就是靠它实现的。</li>
<li><strong>MapReduce</strong>：这个不用再多说了吧，网上解释的例子一大堆，反正通过它，你可以只用写很少量的代码实现分布式计算。  </li>
</ol>
<p>作为开场白，就介绍这么多吧，后续就要开始读书笔记了，看的是董西成的《Hadoop技术内幕：深入解析YARN架构设计和实现原理》。读完整个书再看源码，才意识到如果有人写得代码可以让人专门出书来解读，而且不是瞎吹，硬生生解读成一本书，那是要有多厉害。不过话说回来，我们学的所有代码好像都有对应的书在解读，所以大牛还是很多的，随便看一个都能获益匪浅。</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/动态代理的由来/" itemprop="url">
                  动态代理的由来
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-01T16:47:55+08:00" content="2016-05-01">
              2016-05-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/动态代理的由来/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="动态代理的由来/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们在学习的过程中一直会遇到各种高大上的技术名词或缩写，其中动态代理就是其中之一。之前只是了解过动态代理是代理模式的一种实现，其中JDK的动态代理是基于接口的，CGlib(Code Generation Library)的动态代理是基于类的，通过动态代理可以在原本实现的基础上做到一些增强功能或额外操作，等等，可以说得头头是道，但还是不能做到知根知底，一清二楚。比如基于接口是什么意思？基于类又是什么意思？为什么？怎么个动态法？JDK的动态代理是怎么设计出来的？今天就通过博文揭开动态代理的今生前世，看看它是怎么逆袭成高大上的。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>以下概念引自GOF所著《Design Patterns》的中译本及英文版。</p>
<blockquote>
<p><strong>代理模式</strong><br>    为其他对象提供一种代理以控制对这个对象的访问。<br><strong>Proxy Pattern</strong><br>    Provide a surrogate or placeholder for another object to control access to it.  </p>
</blockquote>
<p>通俗点讲，在代理模式中，至少有两个角色：代理类proxy和被代理类real，外界对real的访问都是通过proxy传达完成的。可以说real对外界是不可见的或者透明的，因为他们对外公开的方法是一模一样的（通过实现相同的接口或继承相同的类保证）。这时proxy相当于一个中介，在外界调用真正到达real时，proxy可以做一些额外操作，比如安全验证、记录访问日志等。下面通过具体的UML图来解释。</p>
<h3 id="模式的组成结构"><a href="#模式的组成结构" class="headerlink" title="模式的组成结构"></a>模式的组成结构</h3><p>这里以基于接口为例来讲，下面是代理模式的UML图。<br><img src="http://cevxd.img47.wal8.com/img47/542077_20160404152451/14622571186.png" alt="UML图"><br>代理模式包括三种角色：</p>
<ul>
<li>抽象主题(Subject)：抽象主题是一个接口，该接口是对象和它的代理所共用的接口，即是RealSubject和Proxy所实现的接口。</li>
<li>实际主题(RealSubject)：实际主题是实现抽象主题接口的类。实际主题的实例是代理角色实例所要代理的对象。</li>
<li>代理(Proxy)：代理是实现抽象主题接口的类(代理和实际主题实现了相同的接口)。代理含有主题接口声明的变量，该变量用来存放RealSubject的实例引用，这样一来，代理的实例就可以控制对它所包含的RealSubject的实例访问，即可以控制对它所代理对象的访问。</li>
</ul>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>登录注册是最常见的基本功能，如果我们还想记录登录的时间，就可以让代理类来完成。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象主题，统一对外公开的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际主题，对外是不可见的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">		System.out.println(username + <span class="string">"登录成功"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理，外界对实际主题访问的中介</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImplProxy</span> <span class="keyword">implements</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line">	<span class="comment">//被代理类的实例</span></span><br><span class="line">	IUserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"当前时间："</span> + Calendar.getInstance().toString());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//调用被代理类的方法</span></span><br><span class="line">		userService.login(username);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>上边写得例子属于动态代理的前身：<strong>静态代理，静态是什么意思呢？对于上边的代码，它是写死的，<em>被代理的方法</em>、<em>被代理的原始类</em>和<em>被代理的接口</em>都是写死固定不变的，即login方法、UserServiceImpl类和IUserService接口是确定的。而动态代理的动态，是指这三者是不确定的，未知的，可变的，不是写死的。</strong>是不是还不太懂？那我们来想一下静态代理都有哪些缺点，为什么需要动态代理。</p>
<p>第一个缺点，对于接口IUserService，如果还有其他的方法，比如注册、修改个人资料等，那就要在代理类中对每一个方法进行一对一的代理，而且每一个代理方法都非常类似，结构如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般化的代理类中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultType <span class="title">methodName</span><span class="params">(ParamType paramName0, ParamType paramName1...)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//实际调用前，增强功能、额外操作</span></span><br><span class="line">	doSomethingBefore();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//调用被代理类的方法</span></span><br><span class="line">	ResultType result = target.methodName(paramName0, paramName1...);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//实际调用后，增强功能、额外操作</span></span><br><span class="line">	doSomethingAfter();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//返回被代理类方法的执行结果</span></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以想象当有很多需要被代理的方法时，会存在大量重复冗余的代码。</p>
<p>第二个缺点，上边第一个缺点只是针对<em>被代理的方法</em>需要变化时带来的不便，那如果<em>被代理的原始类</em>和<em>被代理的接口</em>也需要变化呢？比如现在不只是用户相关的接口(IUserService)需要记录访问时间，其他任何接口都需要记录，即如果当前有N个接口，每个接口中有M个方法，那按照静态代理一对一进行编码，就至少需要写N*M个代理方法，而且结构非常类似，光是想想就爆炸。</p>
<p>那应该怎么改进呢？</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>现在我们针对上边的两个缺点，来一步步分析静态代理是怎么进化成动态代理的。如果不想写那么多重复的，想合并到一起，就需要把写死的变化的部分转化为动态可变的。</p>
<p>对于上边代理方法的结构，变化的部分只有一行，即调用被代理类的方法，其中被代理类target可以不同，对应的方法methodName也可以不同。静态代理中target和methodName是写死的，比如上边的UserServiceImpl和login，那能不能把target和methodName写成变量，比如String类型的，然后在运行时根据传进来的类型名和方法名实现动态调用执行呢？可以吗？有这种技术吗？机智如你有没有想到反射呢？这时上边的代理方法的结构就可以写成如下形式了(示意代码，勿抠细节)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用反射后，通用的代理方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">methodProxy</span><span class="params">(String targetFullName, String methodName, Object[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//实际调用前，增强功能、额外操作</span></span><br><span class="line">	doSomethingBefore();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 *调用被代理类的方法</span><br><span class="line">	 *1. 根据targetFullName反射获取被代理类的实例</span><br><span class="line">	 *2. 根据methodName获取被代理方法的实例methodInstance (java.lang.reflect.Method类型)</span><br><span class="line">	 *3. 调用methodInstance类型的invoke方法完成调用</span><br><span class="line">	 */</span></span><br><span class="line">	Object target = Class.forName(targetFullName).newInstance();</span><br><span class="line">	Method methodInstance = Class.forName(targetFullName).getMethod(methodName, <span class="keyword">new</span> Class[] &#123;</span><br><span class="line">							args[<span class="number">0</span>].getClass(), </span><br><span class="line">							args[<span class="number">1</span>].getClass(),</span><br><span class="line">							......</span><br><span class="line">							&#125;);</span><br><span class="line">	Object result = methodInstance.invoke(target, args);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//实际调用后，增强功能、额外操作</span></span><br><span class="line">	doSomethingAfter();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//返回被代理类方法的执行结果</span></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样写得话就可以做到“一次编写，到处复用”了，每个代理类中所有的代理方法都可以像上边那样，调用并返回methodProxy。不同的只是：在不同的代理类中，变量targetFullName不同；在不同的方法中，变量methodName不同。这时，无论<em>被代理的原始类</em>和<em>被代理的接口</em>是谁，其对应的代理类，结构都非常类似，如下所示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代理，外界对实际主题访问的中介</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyClassName</span> <span class="keyword">implements</span> <span class="title">SubjectInterfaceName</span> </span>&#123;</span><br><span class="line">	<span class="comment">//被代理类的全名称</span></span><br><span class="line">	String targetFullName;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造时绑定被代理类的全名称</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxyClassName</span><span class="params">(String targetFullName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.targetFullName = targetFullName;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//一般化的代理类中的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ResultType <span class="title">methodName0</span><span class="params">(ParamType paramName0, ParamType paramName1...)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用上边的通用方法</span></span><br><span class="line">		<span class="keyword">return</span> (ResultType) methodProxy(targetFullName, methodName0, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">							paramName0,</span><br><span class="line">							paramName1,</span><br><span class="line">							......</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//一般化的代理类中的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ResultType <span class="title">methodName1</span><span class="params">(ParamType paramName0, ParamType paramName1...)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用上边的通用方法</span></span><br><span class="line">		<span class="keyword">return</span> (ResultType) methodProxy(targetFullName, methodName1, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">							paramName0,</span><br><span class="line">							paramName1,</span><br><span class="line">							......</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//......所有SubjectInterfaceName接口中定义的方法都有如上实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面我们已经针对<em>被代理的方法</em>中把变化的部分转化为动态可变的部分，通过反射实现了<em>被代理的方法</em>的改善，使得方法内重复的部分“一次编写，到处复用”。那么对于上边这个代理类的结构，你有没有觉得它也有很多重复冗余的地方呢？想象现在有很多个上边这种结构的代理类，它们不同的的部分有哪些呢：1.代理类的类名ProxyClassName；2.被代理类实现的接口名SubjectInterfaceName；3.内部各个方法签名methodName0(args)，methodName1(args)…；除此之外，所有的代码完全一样，那有没有什么办法能够像参照模版一样，根据给定不同的类名ProxyClassName，接口名SubjectInterfaceName自动生成如上结构的代理类代码呢？是的，你没听错，我们需要的是用代码生成代码的技术，像工厂一样批量生产代理类。可行吗？有这种技术吗？机智如你有没有想到<strong>字节码生成技术</strong>呢？完全可以按照上边的模版拼凑出我们需要的代理类，其中只需要提供需要实现的接口SubjectInterfaceName，类名ProxyClassName没有要求，我们可以自动生成，内部的所有方法名可以通过对接口进行反射获取。</p>
<p>这时我们改善完成的代理模式就进化成了动态代理，只需要我们自己写methodProxy方法中的额外操作，然后指定一个接口，就得到了我们需要的代理类，简单方便，主要有两个组成部分：</p>
<ol>
<li>工厂：利用字节码生成技术，生成指定的代理类；</li>
<li>通用的代理方法；</li>
</ol>
<p>本来想继续用伪码的形式写出一个结构来，但不太好表达，我们还是直接看JDK的动态代理吧，有了上边的理解，你应该就能领会到JDK设计的巧妙了。</p>
<h2 id="JDK的动态代理"><a href="#JDK的动态代理" class="headerlink" title="JDK的动态代理"></a>JDK的动态代理</h2><p>在JDK的动态代理实现中，对应上边工厂组件的是类Proxy，对应通用代理方法methodProxy的是接口InvocationHandler中的invoke方法。为什么是接口呢？因为这样我们可以通过实现该接口自定义需要的增强功能或额外操作，别忘了这才是目的。其中类Proxy中有一个InvocationHandler类型的成员变量h，然后类Proxy生成的代理类(extends Proxy implements SubjectInterfaceName)中，所有的方法调用，都会通过”super.h.invoke(Object, Method, object[])”这行代码委托到我们自定义的invoke方法中。下面我们使用JDK的动态代理实现最开始的登录功能，看看改进的效果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象主题，统一对外公开的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际主题，对外是不可见的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">		System.out.println(username + <span class="string">"登录成功"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的InvocationHandler实现类，主要用来定义通用调用方法中的额外操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">	<span class="comment">//被代理的目标类</span></span><br><span class="line">	<span class="keyword">public</span> Object target;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//通过构造函数绑定目标类</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//通用的调用方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">			<span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">//实际调用前</span></span><br><span class="line">		System.out.println(<span class="string">"之前的额外操作"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//调用代理类的方法</span></span><br><span class="line">		Object result = method.invoke(target, args);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//实际调用后</span></span><br><span class="line">		System.out.println(<span class="string">"之后的额外操作"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//返回调用结果</span></span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//通过Proxy类的静态方法获取代理类的实例</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">				<span class="comment">//当前线程上下文的类加载器</span></span><br><span class="line">				Thread.currentThread().getContextClassLoader(),  </span><br><span class="line">				<span class="comment">//目标类实现的所有接口</span></span><br><span class="line">				target.getClass().getInterfaces(), </span><br><span class="line">				<span class="comment">//当前类，主要用于调用invoke方法</span></span><br><span class="line">				<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//绑定需要代理的类</span></span><br><span class="line">		MyInvocationHandler invocationHandler = <span class="keyword">new</span> MyInvocationHandler(<span class="keyword">new</span> UserServiceImpl());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//利用字节码生成技术生成代理类，并获取其实例(注意声明的类型是IUserService)</span></span><br><span class="line">		IUserService proxy = (IUserService) invocationHandler.getProxy();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//透明地调用对应的方法</span></span><br><span class="line">		proxy.login(<span class="string">"ksni88"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">之前的额外操作</span><br><span class="line">ksni88登陆成功</span><br><span class="line">之后的额外操作</span><br></pre></td></tr></table></figure></p>
<p>可以看到，使用动态代理时，我们根本不用自己写代理类，只用定义我们真正需要的额外操作，然后指定需要被代理的目标类，其他的一切工作都省掉了，相比静态代理可要高明高效的多。看到这里，你可能感觉还不太舒服，因为我们没有自己写代理类，不知道它到底是什么样子，需要看一眼才放心，对吧？我们可以在上边main()方法中加入下面这句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure></p>
<p>之后<strong>在项目目录下新建目录com\sun\proxy</strong>，然后再次运行程序，将在刚才目录下产生一个名为”$Proxy0.class”的代理类Class文件，这就是自动生成的代理类，可以使用<em><a href="http://jd.benow.ca/" target="_blank" rel="external">反编译工具</a></em>看一下它长什么样。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span></span><br><span class="line">  <span class="keyword">extends</span> <span class="title">Proxy</span></span><br><span class="line">  <span class="keyword">implements</span> <span class="title">IUserService</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> $Proxy0(InvocationHandler paramInvocationHandler)</span><br><span class="line">    <span class="keyword">throws</span> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">super</span>(paramInvocationHandler);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object paramObject)</span></span><br><span class="line">    <span class="keyword">throws</span> </span><br><span class="line">  </span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> ((Boolean)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[] &#123; paramObject &#125;)).booleanValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> localError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span><br><span class="line">    <span class="keyword">throws</span> </span><br><span class="line">  </span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> ((Integer)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m0, <span class="keyword">null</span>)).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> localError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> **login**(String paramString)</span><br><span class="line">    <span class="keyword">throws</span> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[] &#123; paramString &#125;);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> localError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span></span><br><span class="line">    <span class="keyword">throws</span> </span><br><span class="line">  </span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> (String)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m2, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> localError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, <span class="keyword">new</span> Class[] &#123; Class.forName(<span class="string">"java.lang.Object"</span>) &#125;);</span><br><span class="line">      m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">      m3 = Class.forName(<span class="string">"testProxy.IUserService"</span>).getMethod(<span class="string">"login"</span>, <span class="keyword">new</span> Class[] &#123; Class.forName(<span class="string">"java.lang.String"</span>) &#125;);</span><br><span class="line">      m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchMethodException localNoSuchMethodException)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(localNoSuchMethodException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException localClassNotFoundException)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(localClassNotFoundException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过以上反编译得到的代码，可以观察到自动生成的代理类有以下几个特点：</p>
<ol>
<li>该代理类继承Proxy类，实现了<em>被代理类实现的接口</em>；</li>
<li>该代理类中的所有方法调用，全部委托到父类Proxy的成员变量InvocationHandler中的invoke方法，从而执行额外操作和反射调用；</li>
<li>该代理类不仅实现了所有接口中定义的方法，还重写了Object类中的equals、hashCode、toString三个方法；</li>
</ol>
<p>看到这里，不知道你有没有完全理解动态代理的设计和由来，反正我是懂了(哈哈。。不懂就多看几遍，多想想)。而在博文一开始提出的问题，现在也可以得到解答了。</p>
<ol>
<li>为什么JDK的动态代理是基于接口的？—因为总要有一个父类或接口来定义代理类和被代理类对外公开的方法，而JDK的动态代理生成的代理类已经继承了Proxy类，所以只能通过接口来定义了。而CGlib生成的代理类，是直接继承被代理类的，所以是基于类的。</li>
<li>什么是基于接口，基于类？—从上一问的回答也可以看出，所谓的基于接口或类，即代理类和被代理类对外公开的方法是由类或接口定义的。</li>
<li>怎么个动态法？怎么设计的？—不懂得就再多看几遍，敲敲想想吧。</li>
</ol>
<h2 id="动态代理的优点"><a href="#动态代理的优点" class="headerlink" title="动态代理的优点"></a>动态代理的优点</h2><p>最后，我还想引用《深入理解JAVA虚拟机》中的原话来总结动态代理的优点，作者总结得实在是太好了，一起来感受一下吧。</p>
<blockquote>
<p>动态代理中所谓的“动态”，是针对使用Java代码实际编写了代理类的“静态”代理而言的，它的优势不在于省去了编写代理类那一点工作量，而是实现了可以在原始类和接口还未知的时候，就确定代理类的代理行为，当代理类与原始类脱离直接联系后，就可以很灵活地重用于不同的应用场景之中。</p>
</blockquote>
<p>你之前是不是觉得不就省了点代码吗？？哈哈，我也是。</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/初探MySQL索引/" itemprop="url">
                  初探MySQL索引
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-14T13:43:03+08:00" content="2016-04-14">
              2016-04-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/初探MySQL索引/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="初探MySQL索引/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在上个月搜狐面试中，面试官看我有很多项目都用到了MySQL，于是问我有没有用过索引，我说没有，然后他诧异地问我遇到过的最大的单表数据量有多大，我赶紧掩饰说没多大也就上万吧，然后就没有然后了。。想来也是羞愧万分，用了这么久的MySQL竟然没有接触过索引，这几天正好需要维护一个去年暑假的项目，跑了大半年数据量已经很大了，借此机会学习实践一下索引。先把最大的体会放出来：对于索引，只能说，不用不知道，用了离不了！</p>
<p>简单介绍一下项目内容：该项目数据库相关的主要是每天定时定期地从6个新闻门户网站上爬取定量的新闻存储到数据库中，以供后期的查取。由于当时需求方要求不高，自己的水平和要求也不高，所以当时既没有使用索引，也没有定期删除过期的新闻数据，结果就造成news新闻表中的数据随着时间的推移无限量增长，两个月前谢帆做iOS版本用接口取数据时更是要等五到十分钟才有反应，当时通过自增id得知表数据近百万了，但由于已经交付大半年了，没有理由主动联系对方，也就无能为力了。这几天对方主动联系做一些小改动，这才下决心学习一下索引，全面改善一下。</p>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>在搜狐面试结束以后，我查过一些关于索引的资料，简单了解了索引的分类、结构、原理等，这么多的内容我也没有进行系统全面的学习，但其中最重要最基础的就是<em><a href="http://www.cnblogs.com/oldhorse/archive/2009/11/16/1604009.html" target="_blank" rel="external">B+树</a></em>了，了解了什么是B+树以后，最好再了解一下<em><a href="http://blog.csdn.net/v_JULY_v/article/details/6530142/" target="_blank" rel="external">索引对B+树的应用</a></em>，看完觉得不过瘾还可以接着看一下<em><a href="http://www.cnblogs.com/hustcat/archive/2009/10/28/1591648.html" target="_blank" rel="external">MySQL索引的原理</a></em>，最后一篇一开始就看可能会不太懂，但只用先记住其中最重要的一条规则：最左前缀原则，经过实践再回头看就柳暗花明了。</p>
<h2 id="索引实践"><a href="#索引实践" class="headerlink" title="索引实践"></a>索引实践</h2><p>先贴出进行实践的数据表结构，非常简单。<br><img src="http://cevxd.img47.wal8.com/img47/542077_20160404152451/146139846939.jpg" alt="表结构"></p>
<h3 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h3><p>先找到需要使用索引的SQL，功能很简单，就是分页获取指定类别的最新新闻的id和title，具体做法是按照date对指定category_id的新闻进行排序，然后按照分页参数选取数据，下面是具体的示例代码。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, title</span><br><span class="line"><span class="keyword">from</span> news_copy</span><br><span class="line"><span class="keyword">where</span> category_id=<span class="number">1</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">date</span> <span class="keyword">desc</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">1000</span>,<span class="number">10</span></span><br></pre></td></tr></table></figure></p>
<p>病急乱投医，按照<em><a href="http://my.oschina.net/leejun2005/blog/96867" target="_blank" rel="external">此文</a></em>给的建议：</p>
<blockquote>
<p>如果对于有where条件，又想走索引用limit的，必须设计一个索引，将where放第一位，limit用到的主键放第2位，而且只能select主键。</p>
</blockquote>
<p>我在该表上建立了联合索引category_id_date=(category_id, date)，这句话是相当精简正确的，但我当时注意力全放在怎么建索引了，没有在意最后一句话，这也造成了后面一些困惑，先且接着往下看。</p>
<h3 id="造大量假数据"><a href="#造大量假数据" class="headerlink" title="造大量假数据"></a>造大量假数据</h3><p>建立完索引，就需要造大量假数据进行测试了，我找到去年开发时的news表，里边存有5000多条数据，然后通过存储过程把该表数据循环添加到另一张结构一样的news_copy表中，循环100次，下图是添加后的数据量。<br><img src="http://cevxd.img47.wal8.com/img47/542077_20160404152451/146139846866.jpg" alt="数据量"><br>可以看到有近60W条数据，下边分别是建索引前后的效果图：<br><img src="http://cevxd.img47.wal8.com/img47/542077_20160404152451/146139847119.jpg" alt="建索引前"><br><img src="http://cevxd.img47.wal8.com/img47/542077_20160404152451/146139847069.jpg" alt="建索引后"><br>可以看到效率相差10倍，而且这个差距肯定会随着数据量的增加而变大。然而，虽然建立索引大大增加了查询效率，但建索引后的查询效率还是不能让我们满意。这时我们就该回头关注SQL本身了，能不能进行优化呢？</p>
<h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h3><p>依然是病急乱投医(不过通过实践遇到问题就解决是最快的学习途径，只是不够系统全面)，查了一通SQL优化以后，在繁杂的搜索结果里有一篇<em><a href="http://www.111cn.net/database/mysql/46425.htm" target="_blank" rel="external">博文</a></em>让我相见恨晚，像是捡了宝一样赶紧按照他说的改了一下SQL：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> n.<span class="keyword">id</span>, title <span class="keyword">from</span> news_copy n</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> news_copy </span><br><span class="line"><span class="keyword">where</span> category_id=<span class="number">1</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">date</span> <span class="keyword">desc</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">1000</span>,<span class="number">10</span>) t</span><br><span class="line"><span class="keyword">on</span> n.<span class="keyword">id</span>=t.<span class="keyword">id</span></span><br></pre></td></tr></table></figure></p>
<p>执行结果如下：<br><img src="http://cevxd.img47.wal8.com/img47/542077_20160404152451/146139847016.jpg" alt="SQL优化后"><br>是不是惊到了？竟然相差近百倍。这又是为什么呢？这里就要引出另外一个概念了：覆盖索引。</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>索引一般用来快速定位想要查询的数据的位置，然后据此精确读取，所以有两步读取操作，第一步读索引，第二步根据索引读数据并返回。换句话说，索引只是用来定位数据，而不是直接返回数据。然而覆盖索引就是一个特例，下面是覆盖索引的概念：</p>
<blockquote>
<p>A covering index is a special case where the index itself contains the required data field(s) and can return the data.  </p>
</blockquote>
<p>其实覆盖索引并不是一个“强概念”，而更像一个简单的名称：当索引字段包含所有需要查询的字段时，可以只读取一次索引就能返回查询结果，这种特例使用到的索引叫做覆盖索引。显而易见，当使用覆盖索引时查询是飞快的（因为不用回表查询）。</p>
<p>读到这里你应该还是不太明白优化后的SQL它具体因为什么变快了，它的执行过程和优化前有什么区别啊？对！你需要了解具体的执行过程才能彻底明白，但在解释两者的执行过程之前，你还需要了解一下SQL语句一般情况下的执行过程和先后顺序（你是不是发现预备知识有点多呢？不要骂娘，谁让我们是半路出家，确实需要一些上下文信息才能理解得清楚明白，我也是顺藤摸瓜，需要什么学什么）。</p>
<h4 id="SQL的整体执行过程"><a href="#SQL的整体执行过程" class="headerlink" title="SQL的整体执行过程"></a>SQL的整体执行过程</h4><p>这里说的执行过程是一个宏观上的，把整个SQL语句当作一个整体，看一下这个整体从执行开始到返回结果都经历了哪些过程（参考：<em><a href="http://www.2cto.com/database/201310/249273.html" target="_blank" rel="external">博文</a></em>）：</p>
<ol>
<li>应用通过MySQL API把查询命令发送给MySQL服务器，然后被解析;</li>
<li>检查权限、MySQL optimizer进行优化，经过解析和优化后的查询命令被编译为CPU可运行的二进制形式的查询计划（query plan），并可以被缓存;</li>
<li>如果存在索引，那么先扫描索引，如果数据被索引覆盖，那么不需要额外的查找，如果不是，根据索引查找和读取对应的记录;</li>
<li>如果有关联查询，查询次序是扫描第一张表找到满足条件的记录，按照第一张表和第二张表的关联键值，扫描第二张表查找满足条件的记录，按此顺序循环;</li>
<li>输出查询结果;</li>
</ol>
<p>这里需要注意的是第3步，这一步是SQL语句真正开始执行的开始，如果没有可用索引，就会进行全表扫描，读取所有记录的<strong>所有字段</strong>；而如果有可用索引，会先扫描索引，然后根据索引读取对应记录的<strong>所有字段</strong>。注意我说的是<strong>所有字段</strong>，而不只是select的字段，至于具体的过程，继续往下看。</p>
<h4 id="SQL的具体先后顺序"><a href="#SQL的具体先后顺序" class="headerlink" title="SQL的具体先后顺序"></a>SQL的具体先后顺序</h4><p>上边讲得是把SQL语句作为一个整体看，这里是深入SQL语句内部，讨论各个SQL关键字的执行先后顺序（参考：<em><a href="http://www.jellythink.com/archives/924" target="_blank" rel="external">博文</a></em>）：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(7)     <span class="keyword">SELECT</span> </span><br><span class="line">(<span class="number">8</span>)     <span class="keyword">DISTINCT</span> &lt;select_list&gt;</span><br><span class="line">(<span class="number">1</span>)     <span class="keyword">FROM</span> &lt;left_table&gt;</span><br><span class="line">(<span class="number">3</span>)     &lt;join_type&gt; <span class="keyword">JOIN</span> &lt;right_table&gt;</span><br><span class="line">(<span class="number">2</span>)     <span class="keyword">ON</span> &lt;join_condition&gt;</span><br><span class="line">(<span class="number">4</span>)     <span class="keyword">WHERE</span> &lt;where_condition&gt;</span><br><span class="line">(<span class="number">5</span>)     <span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;group_by_list&gt;</span><br><span class="line">(<span class="number">6</span>)     <span class="keyword">HAVING</span> &lt;having_condition&gt;</span><br><span class="line">(<span class="number">9</span>)     <span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_condition&gt;</span><br><span class="line">(<span class="number">10</span>)    <span class="keyword">LIMIT</span> &lt;limit_number&gt;</span><br></pre></td></tr></table></figure></p>
<p><em>前边的数字表示该行SQL被执行的次序。</em></p>
<p>SQL执行的开始是FROM语句，查看目标表是否有可用索引（见上），然后取<strong>所有字段</strong>，然后根据WHERE查询条件<strong>选取</strong>满足条件的记录，然后根据SELECT语句<strong>选取</strong>需要的字段，最后根据LIMIT语句<strong>选取</strong>并返回需要的数据结果。所以不要天真地认为每次查询只会读取SELECT指定的字段，查询不是一个从<em>零</em>挑选增加成结果的过程，而是从<em>满</em>筛选去除成结果的过程（其实道理很简单，因为我们需要把所有数据读到内存中进行处理，而不能在文件层面有选择的读取）。</p>
<h4 id="优化后的SQL为什么快"><a href="#优化后的SQL为什么快" class="headerlink" title="优化后的SQL为什么快"></a>优化后的SQL为什么快</h4><p>现在我们终于可以分析一下我们的SQL优化前后具体有什么区别了，先记住一个数据再继续看：表news_copy中category_id=1的记录共5W多条。</p>
<ol>
<li>优化前的执行过程：根据where语句从表news_copy中选出所有category_id=1的记录：这一步因为where字段category_id满足使用索引的最左前缀条件，所以这里是先利用索引读取所有category_id=1的5W多条记录的id（为什么索引里存有主键呢？不明白的可以再仔细看看这篇<em><a href="http://www.cnblogs.com/hustcat/archive/2009/10/28/1591648.html" target="_blank" rel="external">博文</a></em>里的聚簇索引了，前边推荐过），然后根据这5W多个id<strong>回表查询5W多条记录的所有字段</strong>，然后根据order by对这些记录排序（这里可以利用索引），然后根据limit选取从第1000条记录开始的10条记录，然后根据select筛选字段id和title并返回。<br><strong>说明</strong>：上边排序时利用到的了<em><a href="http://dev.mysql.com/doc/refman/5.6/en/limit-optimization.html" target="_blank" rel="external">limit和order by组合使用时的优化</a></em>，所以上边排序时并不是对5W多条记录全排序，而是在前1010条记录排好序后就停止了排序。</li>
<li>现在再来看优化后的执行过程：先执行子查询t，同样利用索引读取5W多个id，但注意这里select只有id字段，所以利用到了覆盖索引，所以这里<strong>不再回表查询5W多条记录的所有字段</strong>，而是直接在索引中完成剩下的order by和limit语句，然后子查询返回了1010条id，这时外查询进行连接查询，<strong>只用根据这1010个id读取1010条记录的所有字段</strong>，然后筛选id和title字段并返回。</li>
</ol>
<p>所以两者的主要差别在于IO读取的数据量，前者高达5W多条，后者只有1010条。<br>对于上边的解释，你可能还会疑问，我怎么知道SQL有没有利用覆盖索引呢？对于平常的SQL，怎么查看SQL的执行效率呢？这就需要神命令EXPLAIN来帮忙了。</p>
<h3 id="explain-amp-show-profile"><a href="#explain-amp-show-profile" class="headerlink" title="explain &amp; show profile"></a>explain &amp; show profile</h3><p>在写这篇博文时，我也想知道我的SQL到底有没有用覆盖索引，网上查了一下发现可以使用explain命令来查看，使用简单方便，可以看下图：<br><img src="http://cevxd.img47.wal8.com/img47/542077_20160404152451/146139846823.jpg" alt="explain优化前"><br><img src="http://cevxd.img47.wal8.com/img47/542077_20160404152451/146139846775.jpg" alt="explain优化后"><br>可以看到输出有很多参数列，其中如果使用了覆盖索引，在最后的Extra列中就会显示“Using index”，否则不会。这里可以清楚的看到优化后的子查询使用到了覆盖索引。其中rows列表示查询可能读取的记录行数，也可以清楚的看到，优化后的SQL在子查询中有5W多行，即5W多个id，然后外查询只有1020行。而优化前的SQL涉及5W多行，不止id，而是所有字段。所以通过explain命令，我们可以大概知道我们的SQL会涉及多大的数据量，会不会使用覆盖索引等信息，其实explain还可以提供给我们更多的信息，前提是你对explain命令的输出足够熟悉，这里不再过多介绍，感兴趣可以看<em><a href="http://dev.mysql.com/doc/refman/5.6/en/explain.html" target="_blank" rel="external">explain命令说明</a></em>和<em><a href="http://dev.mysql.com/doc/refman/5.6/en/explain-output.html" target="_blank" rel="external">explain命令输出参数说明</a></em>。</p>
<p>另外，如果你还想知道SQL在执行的各个阶段的耗时，比如CPU、IO等详细信息，可以看一下<em><a href="http://dev.mysql.com/doc/refman/5.6/en/show-profile.html" target="_blank" rel="external">show profile</a></em>命令，但该命令在版本5.6.7中被弃用了，转而被<em><a href="http://dev.mysql.com/doc/refman/5.6/en/performance-schema-query-profiling.html" target="_blank" rel="external">Performance Schema</a></em>替代。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>对于这个项目的维护，<a href="http://moonfacex.github.io/blog/" target="_blank" rel="external">梦非</a>早就催我让我改善一下，但我总是推脱，既不想费心维护一个已经交付的项目，也不想费力去学习索引，而一直拖到该项目又有改动时才动手学习。平时我们可能有很多这种情况，给自己找各种不动手学习的借口：索引？哪来那么多数据让我测啊？分布式？哪来那么多机器让我试啊？而又总是在关键时刻方恨少。其实只要我们下定决心，稍微推动自己一下下，就能获益匪浅，而对于学习掌握的知识，一定是有用的，只是时间早晚而已。这篇博文我是14号开始着手整理写得，写一半的时候，17号腾讯面试就又问了索引，基本把博文讲了一遍，当时简直庆幸自己刚学过索引。另外关于写博客本身，也是获益匪浅，写的过程就是把自己的理解和思路表达出来的过程，不仅能加深自己的理解，发现盲点，还能锻炼自己的表达沟通能力，现在我写一篇博文大概要一周时间，举步维艰，相信坚持下去会有提高。</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/valotile和Java内存模型/" itemprop="url">
                  volatile和Java内存模型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-10T13:37:23+08:00" content="2016-04-10">
              2016-04-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/valotile和Java内存模型/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="valotile和Java内存模型/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>本文是在读了周志明老师的《深入理解Java虚拟机》之后写得，算是读书笔记吧，部分讲解思路和图均出自此书，因为我想不出比这种讲解思路更容易理解的讲法。</em></p>
<p>在接触volatile之前，我们只知道“原子性”，原子性很好理解，这里也不再啰嗦。但当volatile引出“可见性”的时候，就不像原子性那样可以一两句说清楚说明白了。上网一查还总是让我们先学一下Java的内存模型，难道就不能像原子性那样简单直白的说明白吗？其实我们可以回想一下第一次接触“原子性”的时候是怎么去理解的，原子性就是它的字面意思，一个操作像原子(虽然物理上的原子还是可分的，引用东哥的话说，不要在意这些细节)那样是细不可分的，最小的操作。但我们真正理解和明白原子性，是通过知道了汇编语言和机器语言之后的事。因为正是由于高级语言要编译成汇编语言，最后对应于机器语言才能执行的这个过程，造成了高级语言存在非原子性操作的问题。同样的，可以说是Java的内存模型造成了可见性这个问题，所以如果想从原理上，而不只是字面上去理解“可见性”，确实需要先学一下Java的内存模型，其实是很简单的一个东西。</p>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>为了更容易地理解Java内存模型，我们可以参考一下本科学过的硬件上的缓存设计。为了协调存储设备和处理器之间的速度差距，所以引入了高速缓存Cache：将运算需要使用到的数据复制到Cache中，在运算过程中CPU只在Cache上进行存取，在运算结束以后再把Cache中的数据同步写回到内存中，这样避免了CPU等待相对缓慢的内存读写，交互关系如下图：<br><img src="http://cevxd.img47.wal8.com/img47/542077_20160404152451/146027091076.png" alt="处理器、高速缓存、主内存间的交互关系"><br><em>上图中的缓存一致性协议不是重点，重点是这种结构设计。</em><br>类似的，Java内存模型规定，所有的变量(不包括局部变量和方法参数这种线程私有的，不会被共享的变量)都存储在主内存中(此处的主内存是虚拟机内存的一部分)，每条线程还有自己的工作内存(可与上边的Cache类比)，线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间也无法直接访问对方的工作内存，线程间的变量传递均通过主内存完成，交互关系如下图：<br><img src="http://cevxd.img47.wal8.com/img47/542077_20160404152451/14602709108.png" alt="线程、工作内存、主内存间的交互关系"><br><em>同样的，上图中的交互操作不是重点，重点是这种结构设计。</em><br><strong>需要注意的是，这里所讲的主内存、工作内存，均是虚拟机内存的一部分，它们和JVM内存区域中的Java堆、栈、方法区等不是同一个层次的内存划分，前者更偏向逻辑上的划分，后者更偏向物理上的划分，如果要强行对应的话，主内存主要对应于Java堆中的对象实例数据部分，工作内存主要对应于栈中的部分区域。</strong></p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>在了解了Java内存模型以后，我们再去理解“可见性”时，就清楚明白多了。正因为工作内存的存在，所以某些线程正在操作的共享变量可能不是最新值，这就造成了“不可见性”问题。所以</p>
<blockquote>
<p>可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。  </p>
</blockquote>
<p>那要怎么保证可见性呢？很简单，只要消除造成“不可见性”的原因————工作内存就好了，是的，如果能够跳过工作内存，直接操作主内存，那就一定是可见的，但这样就破坏了这种结构设计。所以正常的，也是Java volatile关键字采用的，用以下两条规则保证可见性：</p>
<ol>
<li>在每次修改该变量后，<strong>立即</strong>从工作内存同步写回到主内存中；</li>
<li>在每次使用该变量前，<strong>立即</strong>从主内存中再读取到工作内存中；  </li>
</ol>
<p><strong>要注意的是，volatile变量也是有工作内存副本的，它并没有破环这种结构设计，它与普通变量的区别仅仅是以上两条规则，即读取和写回的及时性。</strong></p>
<h3 id="Java中保证可见性的关键字"><a href="#Java中保证可见性的关键字" class="headerlink" title="Java中保证可见性的关键字"></a>Java中保证可见性的关键字</h3><p>在Java中，一共有三个关键字可以保证可见性：</p>
<ol>
<li>volatile：通过上边两条规则保证；</li>
<li>final：初始化后不可变，不存在修改的情况；</li>
<li>synchronized：通过内存交互规则之一保证，“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中”，注意此处说的并不是同步块中的操作，而单单是指被synchronized修饰的变量本身。</li>
</ol>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h3 id="对volatile的误解"><a href="#对volatile的误解" class="headerlink" title="对volatile的误解"></a>对volatile的误解</h3><p>至于具体的误解是什么，我就不说了，因为在我身上经常发生本来记得很对的概念，看了一眼反例就再也分不清了的蠢事。所以这里只把结论放出来，并解释为什么会这样。</p>
<blockquote>
<p>volatile只能保证被修饰变量的可见性，不保证对其操作的原子性，对其所有的操作都和普通变量一样是非线程安全的。  </p>
</blockquote>
<p>volatile对变量的影响仅仅只是可见性，这是我们一直强调的一点，如果你已经理解了什么是可见性，但当可见性和原子性这两个概念放在一起时有点晕的话，看了下边的例子可能就清楚多了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> num;</span><br><span class="line">num++;</span><br></pre></td></tr></table></figure></p>
<p>如果volatile能保证变量操作的原子性，那上边num++这个操作应该是原子操作，即它应该是一个细不可分的、不会被“中途打断”的操作，但稍微清醒一点的你也会意识到这是不可能的。这个操作最起码要分成三个原子操作才能完成：</p>
<ol>
<li>读取num当前值；</li>
<li>对num当前值进行加1运算；</li>
<li>回写运算后的num值；  </li>
</ol>
<p>在多线程环境下，任一个正在进行num++操作的线程，都有可能在上边三个原子操作之间的任一点被切换上下文。这也是可以通过Javap反汇编印证的，下边是num++反汇编对应的字节码指令：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic</span><br><span class="line">iconst_1</span><br><span class="line">iadd</span><br><span class="line">pustatic</span><br></pre></td></tr></table></figure></p>
<p>可以清楚的看到num++操作被编译成了四条字节码指令，所以可见性和原子性之间并没有什么必然联系，而volatile只保证变量的可见性，对于num++这个操作而言，volatile的唯一作用是，当且仅当putstatic指令执行完以后，任一线程通过getstatic指令读取到的num值都是最新的。(这里用字节码来说明原子性不是很严谨，因为即使编译出来只有一条字节码指令，也并不意味着执行这条指令就是一个原子操作，因为一条字节码指令在真正被执行时可能会转化为多条本地机器码指令，所以通过汇编代码而非字节码指令会更严谨一些，但此处使用字节码就已经能说明问题了)。</p>
<h3 id="volatile的两个作用"><a href="#volatile的两个作用" class="headerlink" title="volatile的两个作用"></a>volatile的两个作用</h3><p>前边我们一直在讲volatile能保证可见性，其实这只是它的作用之一，它还有另外一个作用就是禁止指令重排序优化。</p>
<blockquote>
<p>从硬件架构上讲，指令重排序是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理。但并不是说指令任意重排，CPU需要能正确处理指令依赖情况以保障程序能得出正确的执行结果。 </p>
</blockquote>
<p>可以结合CPU流水线理解上边的概念。那指令重排序对程序的并发执行又有什么影响呢？为什么volatile要禁止指令重排序呢？下边通过DCL单例模式的代码来说明。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">				<span class="keyword">if</span>(instance == <span class="keyword">null</span>)</span><br><span class="line">					instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//do something</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果instance没有使用volatile修饰，那么instance = new Singleton()对应的指令就有可能被重排序。该行代码起码有三个步骤需要完成：</p>
<ol>
<li>在Java堆中分配一块内存用来存储Singleton实例；</li>
<li>在该内存块上初始化Singleton实例；</li>
<li>将该内存块对应的地址引用赋值给instance；</li>
</ol>
<p>现在假设有线程A调用了Singleton.getInstance()，当执行到instance = new Singleton()这行代码时，经过指令重排序，上边第3个步骤被重排序到第2个步骤之前，并在执行了第3个步骤以后，将要执行第2个步骤之前，进行上下文切换至线程B，线程B再调用Singleton.getInstance()方法时，instance已经不等于null了，这时再继续调用doSomething()方法时，由于还没有初始化，所以会出现异常。虽然这种情况非常极端，但不是没有可能，所以只有使用volatile修饰instance的DCL单例模式才是线程安全的(在JDK1.5之前volatile还不能完全屏蔽指令重排序，所以即使使用volatile也不能保证DCL单例模式的线程安全，但在JDK1.5修复此问题之后完全是线程安全的)。</p>
<h3 id="volatile的底层实现原理"><a href="#volatile的底层实现原理" class="headerlink" title="volatile的底层实现原理"></a>volatile的底层实现原理</h3><p>这里所说的实现原理，即JVM是怎么实现volatile的可见性和禁止指令重排序这两个特性的。这时我们可以对比观察使用volatile和不使用volatile关键字时所生成汇编代码的差别，具体的代码不再贴出(纯汇编，贴出来意义不大不是重点)，感兴趣可以自行实验。其中一个明显的差别是，在volatile变量每次赋值指令之后，都会紧随一条“lock add1 $0x0,(%esp)”指令(不一定是ESP寄存器，也可能是其他寄存器，取决于栈指针的指向)。这个操作就相当于传说中的<strong>内存屏障</strong>，以下引用《深入理解Java虚拟机》中的原话来说明该指令是如何保证可见性的：</p>
<blockquote>
<p>当只有一个CPU访问内存时，并不需要内存屏障，但如果有两个或更多CPU访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。这条指令中的“add1 $0x0,(%esp)”(把ESP寄存器的值加0)显然是一个空操作(采用这个空操作而不是空操作指令nop是因为IA32手册规定lock前缀不允许配合nop指令使用)，关键在于lock前缀，查询IA32手册，它的作用是<strong>使得本CPU的Cache写入了内存，该写入动作也会引起别的CPU或者别的内核无效化其Cache</strong>，所以通过这样一个空操作，可让前面volatile变量的修改对其他CPU立即可见。  </p>
</blockquote>
<p>这段引用的重点在于后半句，关于lock前缀的解释，也就是volatile是使用硬件指令来保证可见性的。那lock前缀又是怎么保证禁止指令重排序呢？依然通过引用《深入理解Java虚拟机》中的原话来说明：</p>
<blockquote>
<p>从硬件架构上讲，指令重排序是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理。但并不是说指令任意重排，CPU需要能正确处理指令依赖情况以保障程序能得出正确的执行结果。譬如指令1把地址A中的值加10，指令2把地址A中的值乘以2，指令3把地址B中的值减去3，这时指令1和指令2是有依赖的，它们之间的顺序不能重排————(A+10)*2与A*2+10显然不相等，但指令3可以重排到指令1、2之前或者中间，只要保证CPU执行后面依赖到A、B值的操作时能获取到正确的A和B值即可。所以在本内CPU中，重排序看起来依然是有序的。因此，lock add1 $0x0,(%esp)指令把修改同步到内存时，意味着所有之前的操作都已经执行完成，这样便形成了“指令重排序无法越过内存屏障”的效果。  </p>
</blockquote>
<p>看了上边的引用，你可能还是一头雾水，这个解释给人的感觉像是只可意会不可言传一样，而且关于内存屏障，《深入理解Java虚拟机》一书并没有过多介绍，只说“重排序时不能把后面的指令重排序到内存屏障之前的位置”，但这个限制显然是不够的，难道屏障之前的代码就可以重排序了？那DCL单例模式依然是有问题的。应该有更严格的限制才对，比如绝对禁止屏障前后的代码重排序。经过进一步google，也找到一些说明，但由于太偏向底层，我也没有太深究，引用一篇<em><a href="http://jpbempel.blogspot.com/2013/05/volatile-and-memory-barriers.html" target="_blank" rel="external">博文</a></em>中的话简单说明一下内存屏障：</p>
<blockquote>
<p>with lock prefix, memory related instructions are processed specially to act as a memory barrier, similar to mfence instruction. Dave Dice explains in his blog that they benchmarked the 2 kinds of barrier, and the lock add seems the most efficient one on today’s architecture. So this barrier ensures that there is no reordering before and after this instruction and also drains all instructions pending into Store Buffer. After executing these instructions, all writes are visible to all other threads through cache subsystem or main memory. This costs some latency to wait for this drain.  </p>
</blockquote>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>之前刚接触volatile时，看到过一个说法，volatile只适合简单的get和set方法，当时不太懂。这次在查内存屏障时，不知道在哪看到一句话，意思是对于volatile变量，单独的读操作和单独的写操作是原子操作，但任意的读写操作的组合不再是原子操作，这句话像是戳破了最后一张纸一样，一句话解释清楚了之前num++不是原子操作的原因，并给出了言简意赅的结论。这时再回头去查之前那个说法时才恍然大悟，看<em><a href="http://www.blogjava.net/bolo/archive/2014/06/20/414971.html" target="_blank" rel="external">下面代码</a></em>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.i = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我说，上边的get和set方法对于变量i的操作，不但是原子操作，而且两个方法之间还是同步的，即此处volatile的作用完全等同于synchronized的作用，你是不是需要思考一会？这么神奇吗？</p>
<p>先来解释为什么是同步的，我们可以先用熟悉的synchronized想一下同步效果是什么样。如果两个方法是synchronized修饰的，那多线程环境下，任一时刻只有一个线程在执行get和set方法，其他线程都处于阻塞排队状态，则，任一时刻，任一线程通过get方法得到的，一定是变量i此刻的最新值。这就是synchronized在此处达到的同步效果，是不是很熟悉？这不就是保证了变量i的可见性嘛。再来看此处volatile达到的同步效果，由于volatile语义使然，同样的，任一时刻，任一线程通过get方法得到的，一定是变量i此刻的最新值。</p>
<p>再来解释原子性，这时我们可以考虑一下如果变量i没有使用volatile修饰，结合我们上边说的内存模型，当一个线程A执行this.i=i时，其实至少是有两步的：1.对工作内存中的i进行写操作；2.把工作内存中的i同步回写到主内存中；那么当在这两步之间进行上下文切换至其他线程时，通过get方法将看不到i的最新值。而volatile可以保证this.i=i这行代码的原子性。此处的原子性可能和我们通常理解的原子性不太一样，因为我们之前遇到的原子性都是在机器码的层面上，而这里是由于JAVA的内存模型导致的。</p>
<p>这时我们不妨回头想一下当看到“两个方法之间还是同步的，即此处volatile的作用完全等同于synchronized的作用”这句话时为什么会有点诧异呢？因为我们通常理解的“同步”，更多的关注点在于“原子性”上，因为我们通常需要同步的操作不像上边的代码只有一行，而是一系列相关的操作。而此处的“同步”，更多的关注点在于“可见性”上，所以只能说我们对于“同步”的认识还不够深。</p>
<p>关于volatile的正确用法，还有很多需要学习，这里推荐一篇很好的博文<em><a href="http://www.ibm.com/developerworks/cn/java/j-jtp06197.html" target="_blank" rel="external">《正确使用 Volatile 变量》</a></em>，值得一看。最后通过引用《深入理解Java虚拟机》书中的话来结束此文，既作为对内存模型的总结，更作为对“同步”的正确认识和理解。</p>
<blockquote>
<p>Java内存模型是围绕着并发过程中如何处理原子性、可见性和有序性这3个特征来建立的。<br>有序性：Java程序中天然的有序性可以总结为一句话：如果在线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。</p>
</blockquote>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/线程池全面解析/" itemprop="url">
                  线程池全面解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-04T15:09:33+08:00" content="2016-04-04">
              2016-04-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/线程池全面解析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="线程池全面解析/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于线程池，我在项目中只是简单的使用，大概知道JDK有四种线程池，但对于具体的实现和原理并不是很清楚，所以本文是在对线程池有一些了解之后，结合源码全面总结并讲解JDK线程池的实现和原理。但在开写之前呢，并没有预想到线程池有这么大的内容量，本想一下午看完，结果看了两三天，笔记也是越写越长，显得有些杂乱，可以根据目录按需选看。</p>
<h2 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a>为什么要使用线程池？</h2><p>诸如 Web 服务器、数据库服务器、文件服务器或邮件服务器之类的许多服务器应用程序都面向处理来自某些远程来源的大量短小的任务。不管请求如何到达，服务器应用程序中经常出现的情况是：单个任务处理的时间很短而请求的数目却是巨大的。构建服务器应用程序的一个过于简单的模型应该是：每当一个请求到达就创建一个新线程，然后在新线程中为请求服务。然而对于原型开发这种方法工作得很好，但如果试图部署以这种方式运行的服务器应用程序，那么这种方法的严重不足就很明显。比如创建和销毁线程的时间比真正执行任务的时间还多、过多的线程创建造成系统不稳定甚至崩溃。</p>
<p>线程池为线程生命周期开销问题和资源不足问题提供了解决方案，使用线程池的好处有以下三点：</p>
<ol>
<li>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗；</li>
<li>提高响应速度：当任务到达时，任务可以不需要的等到线程创建就能立即执行；</li>
<li>提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ol>
<h2 id="最简单的线程池模型"><a href="#最简单的线程池模型" class="headerlink" title="最简单的线程池模型"></a>最简单的线程池模型</h2><p>至少要有两个集合，其中一个集合用来存放线程，另一个集合用来存放等待执行的任务。针对线程的个数控制、任务执行的顺序、没有可用线程或任务满了以后对应的策略，JDK提供了几种常用的、实现好的线程池供我们使用，下面详细讲解JDK的线程池（这里先抛出一个重要的问题，对于这个简单模型，我只说了它静态的存储结构，但它的动态操作，比如把任务交给线程来执行这个动作是怎么完成的？线程执行完以后又怎么达到线程复用的？在讲解完JDK的四种线程池以后，我会在此文最后通过源码来回答这些问题）。</p>
<h2 id="JDK提供的线程池"><a href="#JDK提供的线程池" class="headerlink" title="JDK提供的线程池"></a>JDK提供的线程池</h2><h3 id="UML图："><a href="#UML图：" class="headerlink" title="UML图："></a>UML图：</h3><p><img src="http://cevxd.img47.wal8.com/img47/542077_20160404152451/145975477752.png" alt="JDK线程池UML"></p>
<p>标记一下比较重要的类：<table><tr><td>ExecutorService</td><td>真正的线程池接口</td></tr><tr><td>ScheduledExecutorService</td><td>能和Timer/TimerTask类似，解决那些需要任务重复执行的问题</td></tr><tr><td>ThreadPoolExecutor</td><td>ExecutorService的默认实现</td></tr><tr><td>ScheduledThreadPoolExecutor</td><td>继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现</td></tr></table></p>
<h3 id="ThreadPoolExecutor构造参数"><a href="#ThreadPoolExecutor构造参数" class="headerlink" title="ThreadPoolExecutor构造参数"></a>ThreadPoolExecutor构造参数</h3><p>对于我们上边提到的JDK提供的几种常用的线程池，其实都是通过ThreadPoolExecutor构造的，只是构造参数不同导致各个线程池的特性不同，所以在介绍那几种具体的线程池之前，先来了解一下ThreadPoolExecutor各个构造参数的含义，下边是其构造函数代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">					  <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">					  <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">					  TimeUnit unit,</span><br><span class="line">					  BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">					  ThreadFactory threadFactory,</span><br><span class="line">					  RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">	maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">	maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">	keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"><span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"><span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line"><span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line"><span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line"><span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line"><span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line"><span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到最多可以配置7个参数，下边一一讲解：</p>
<ol>
<li>corePoolSize：池中保存的所有线程的个数，包括空闲线程，也叫核心线程数；</li>
<li>maximumPoolSize：池中允许的最大线程个数；</li>
<li>keepAliveTime：当现有线程个数大于corePoolSize时，此为终止多余的空余线程等待新任务的最长时间；</li>
<li>unit：keepAliveTime参数的时间单位；</li>
<li><p>workQueue：用于保存待执行的任务的阻塞队列（BlockingQueue<runnable>，（上边提到还要有一个集合用于存放线程，JDK并没有提供可设置的方法，默认使用HashSet）阻塞队列和普通队列的区别如下表，它多了一些可能会造成阻塞的操作，如取的时候队列是空的，存的时候队列是满的情况（内部使用的是ReentrantLock进行同步，所以可以选择使用公平锁，Condition作为信号量）：<table><tr><th width="8%">\</th><th width="20%">可能报异常</th><th>返回布尔值/null</th><th width="15%"><font color="red">可能阻塞</font></th><th><font color="red">可能阻塞指定时间</font></th></tr><tr><td>入队</td><td>add(e)</td><td>boolean offer(e)</td><td>put(e)</td><td>offer(e, timeout, unit)</td></tr><tr><td>出队</td><td>remove(e)</td><td>E poll()</td><td>take()</td><td>poll(timeout, unit)</td></tr><tr><td>查看</td><td>element()</td><td>E peek()</td><td>无</td><td>无</td></tr></table></runnable></p>
<ul>
<li>其中JDK提供了六种（前五个都extends AbstractQueue<e>  implements BlockingQueue<e>，第六个的泛型为Runnable）：<ol>
<li>ArrayBlockingQueue<e>：一个基于数组结构的有界阻塞队列，大小不可动态扩展，遵循FIFO原则；内部实现有三个int变量，count用来判断满或空，putIndex用于指示下一个可以存放的位置，takeIndex用于指示下一个可以取的位置，所以写操作并没有造成复制移动。</e></li>
<li>LinkedBlockingQueue<e>：一个基于链表结构的无界阻塞队列，默认大小是MAX_VALUE，如果构造时指定了大小，则大小是不可动态扩展的，遵循FIFO原则；内部实现有静态内部类Node<e>，空的头引用head（item==null），尾引用last，AtomicInteger count用来判断满或空。</e></e></li>
<li>SynchronousQueue<e>：一个不存储元素的阻塞队列，进出队列的顺序取决于是否采用公平模式，之所以不存储元素，是因为它的每一个put操作，都要阻塞等待一个poll操作，反之亦然，所以该队列不存在peek、遍历等操作；内部实现复杂，没看懂，类注释说明是对“dual stack and dual queue”的扩展实现，LIFO stack适用于非公平模式，FIFO queue适用于公平模式。</e></li>
<li>PriorityBlockingQueue<e>：一个基于平衡二叉堆(数组，n，2n+1，2n+2)的无界阻塞队列，进出队列的顺序取决于排序顺序，排序标准基于提供的Comparator或者元素的natural order，大小可以动态扩展，默认初始大小为11，最大限制为MAX_VALUE-8（避免某些VM OOM），存操作会对堆调整，取操作会取走堆顶元素（array[0]）；</e></li>
<li>DelayQueue<e extends="" delayed="">：一个内部使用PriorityQueue<e>（基于平衡二叉堆(数组，n，2n+1，2n+2)）的无界阻塞队列，性质同上，其中Delayed是一个接口，内部只有一个方法long getDelay(TimeUnit unit)，该接口还继承了Comparable<delayed>接口。排序标准：队头是过期（即getDelay方法返回值小于等于0）时间最长的元素，即getDelay返回值最小的元素，如果没有过期的元素，也就没有队头，此时poll方法会返回null，take方法会阻塞，其他所有方法不检查是否过期，和普通队列一样。</delayed></e></e></li>
<li>DelayedWorkQueue：一种特殊的DelayQueue（所以上述特性都适用），属于ScheduledThreadPoolExecutor的静态内部类，也是基于平衡二叉堆的无界阻塞队列（唯一的区别是，如果元素类型是ScheduledFutureTask的话，还会设置每个ScheduledFutureTask在堆中的heapIndex，提高其取消和删除的效率）。但其内部使用的数组类型不是泛型，而是写死的RunnableScheduledFuture，所以该队列的元素类型只能是RunnableScheduledFuture。但使用该队列时，必须声明为BlockingQueue<runnable>，解释如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Specialized delay queue. To mesh with TPE declarations, this</span><br><span class="line"> * class must be declared as a BlockingQueue&lt;Runnable&gt; even though</span><br><span class="line"> * it can only hold RunnableScheduledFutures.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedWorkQueue</span> <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">Runnable</span>&gt;</span><br><span class="line">	<span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">Runnable</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">/*class code*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</runnable></li>
</ol>
</e></e></li>
</ul>
</li>
<li><p>threadFactory：创建新线程时使用的工厂，该接口只有一个方法：Thread newThread(Runnable r)；使用的默认工厂只是对Thread进行了命名，原封不动的包装了Runnable的run方法，可以通过自己的实现达到一些自定义的包装效果；</p>
</li>
<li><p>handler：当现有线程个数等于maximumPoolSize &amp;&amp; 队列已满的时候，对新提交的任务的处理策略，JDK提供了四种可选的策略，对应的实现其实很简单，可以通过实现RejectedExecutionHandler接口自定义处理策略，该接口只有一个方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br></pre></td></tr></table></figure>
<p> 下边详细看JDK实现的四种策略：</p>
<ul>
<li><p>AbortPolicy：直接抛出异常，方法体如下：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">										 <span class="string">" rejected from "</span> +</span><br><span class="line">										 e.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>DiscardPolicy：没有任何处理，丢弃掉，方法体如下：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>DiscardOldestPolicy：取出并丢弃掉队列头的任务，然后重新添加，方法体如下：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">		e.getQueue().poll();</span><br><span class="line">		e.execute(r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CallerRunsPolicy：由提交该任务的线程直接执行该任务，方法体如下：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">		r.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="线程池的处理流程"><a href="#线程池的处理流程" class="headerlink" title="线程池的处理流程"></a>线程池的处理流程</h3><p><img src="http://cevxd.img47.wal8.com/img47/542077_20160404152451/145975630954.png" alt="线程池的处理流程"><br>如上图所示，大体流程依次如下：</p>
<ol>
<li><strong>第一步</strong> 是 看线程池是否关闭 &amp;&amp; corePoolSize是否满了；</li>
<li>corePoolSize满了以后，<strong>第二步</strong> 是看 线程池是否关闭 &amp;&amp; 队列是否满了（判断队列是否已满用的是上表中的offer(e)方法），此处对线程池的状态检查是double check，即添加到队列以后，会再次检查状态，如果此时线程池是关闭状态，则回滚刚才的添加动作。</li>
<li>队列满了以后，<strong>第三步</strong>是看 线程池是否关闭 &amp;&amp; maximumPoolSize是否满了；</li>
<li>maximumPoolSize满了以后，<strong>第四步</strong>，也是最后一步，再执行拒绝策略。<br><em>特别要注意判断队列已满和maximumPoolSize已满的先后顺序</em></li>
</ol>
<h3 id="JDK提供的四种常用的线程池"><a href="#JDK提供的四种常用的线程池" class="headerlink" title="JDK提供的四种常用的线程池"></a>JDK提供的四种常用的线程池</h3><p>提供这四种线程池的类是Executors，该类相当于一个工厂类，提供四种线程池和一些通用方法，现在的关注点是这四种线程池，前边已经提到它们都是通过ThreadPoolExecutor构造的，只是参数不同导致它们特性不同，下边通过源码进行讲解。</p>
<ol>
<li><p>FixedThreadPool：固定大小线程池</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">								  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">								  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 可以看到，它的corePoolSize == maximumPoolSize，这有两点影响，1. 线程个数不会增长，即永远不会走上述流程中的第三步，当队列满了以后，直接执行拒绝策略；2. 不会存在大于corePoolSize的额外线程，所以线程池中的所有线程不会因为空闲时间太长而终止，当且仅当整个线程池ShutDown时才终止，所以第三、四个参数是无用的。同时也可以看到它使用的是无界阻塞队列，<strong>所以要么所有任务正常执行或等待执行，要么任务实在太多OOM造成系统崩溃，拒绝策略永远不会被执行</strong>。而且当有线程因为任务抛出异常而终止时，线程池会新建一个线程顶替它，不会出现线程泄露。</p>
</li>
<li><p>SingleThreadPool：单线程池</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">		(<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">								<span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">								<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 可以看到，它就是一个corePoolSize和maximumPoolSize都为1的FixedThreadPool。所以<strong>以上所说的性质也都适用于它。它可以保证任务的顺序执行</strong>。</p>
</li>
<li><p>CachedThreadPool：缓存线程池</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">								  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">								  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 可以看到，它的corePoolSize==0，maximumPoolSize==Integer.MAX_VALUE，队列使用的是SynchronousQueue，最长空闲时间是60s。所以它的性质如下：</p>
<ul>
<li>因为corePoolSize==0，所以当该线程池空闲足够长的时间时（单个线程最长空闲时间是60s），线程池中就没有存储任何线程了，没有任何消耗；</li>
<li>因为corePoolSize==0，所以按照上述线程池的流程，每次到来新任务时，第一步，当前线程个数总是&lt;corePoolSize的，所以新任务总会走第二步，尝试加到队列里。而又因为它使用的队列是SynchronousQueue，以及添加到队列的操作使用的是offer(e)方法，此方法只有当前正好有线程等待取数据时才会返回true，所以此处它永远返回false，即相当于队列永远是满的，所以新任务总会走第三步，而又因为maximumPoolSize==Integer.MAX_VALUE，<strong>所以对于到来的新任务，总会新建线程去执行它。要么所有任务正常执行，要么任务实在太多OOM造成系统崩溃，拒绝策略永远不会被执行</strong>，这和FixedThreadPool是一样的，但两者如果造成OOM的话，原因是不同的，FixedThreadPool是因为队列所占空间，CachedThreadPool是因为线程所占空间。</li>
</ul>
</li>
<li><p>ScheduledThreadPool：调度线程池</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, TimeUnit.NANOSECONDS,</span><br><span class="line">		  <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 该线程池和以上线程池大不相同，需要另开一篇专门讲解。但其特性是，可以让任务延迟指定的时间执行，也可以让任务在指定的间隔时间内重复执行。要使用这些特性，就必须使用其新增的ScheduledFutureTask方法，而如果使用execute方法的话，它会包装成delay=0的任务按照延迟任务来执行。</p>
</li>
</ol>
<h2 id="JDK线程池实现原理"><a href="#JDK线程池实现原理" class="headerlink" title="JDK线程池实现原理"></a>JDK线程池实现原理</h2><p>线程池的整体流程我们上边已经说了，但其中的细节和关键点并没有提及，现在通过源码来看其具体是怎么实现的。</p>
<ol>
<li><p>其实上边说的整体流程，全部是在execute方法中控制的，源码如下，不再累述：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Proceed in 3 steps:</span><br><span class="line">	 *</span><br><span class="line">	 * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="line">	 * start a new thread with the given command as its first</span><br><span class="line">	 * task.  The call to addWorker atomically checks runState and</span><br><span class="line">	 * workerCount, and so prevents false alarms that would add</span><br><span class="line">	 * threads when it shouldn't, by returning false.</span><br><span class="line">	 *</span><br><span class="line">	 * 2. If a task can be successfully queued, then we still need</span><br><span class="line">	 * to double-check whether we should have added a thread</span><br><span class="line">	 * (because existing ones died since last checking) or that</span><br><span class="line">	 * the pool shut down since entry into this method. So we</span><br><span class="line">	 * recheck state and if necessary roll back the enqueuing if</span><br><span class="line">	 * stopped, or start a new thread if there are none.</span><br><span class="line">	 *</span><br><span class="line">	 * 3. If we cannot queue task, then we try to add a new</span><br><span class="line">	 * thread.  If it fails, we know we are shut down or saturated</span><br><span class="line">	 * and so reject the task.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">int</span> c = ctl.get();</span><br><span class="line">	<span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">		<span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		c = ctl.get();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">		<span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">		<span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">			reject(command);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">			addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">		reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>要说明的是，线程池把其中的线程包装成一个Worker类，该类实现了Runnable接口，内部定义了两个重要的成员变量：</p>
<ul>
<li>一个Runnable firstTask成员变量用来保存要执行的任务，然后在自己的run方法中调用firstTask的run方法；</li>
<li>成员变量Thread t，每个Worker就是在这个线程t中运行的，其中t是由构造函数中指定的线程工厂生产的。这个设计有点绕，因为我们一般写得Runnable都是在本类外new一个Thread来执行自己，但这个Worker是自己指定由哪个Thread来执行自己，控制权在自己手里，外界需要先从Worker这里获取到这个Thread，然后start。上图中的addWorker（command，true）方法就是构造一个Worker，然后添加到HashSet中，然后获取其成员变量Thread t，然后t.start()开始执行该任务（该方法略长，不上代码了，方法参数command就是要执行的任务Runnable类，第二个参数为true时，检查线程个数时上限以corePoolSize为准，否则以maximumPoolSize为准）。</li>
</ul>
</li>
<li><p>那么问题来了，这个线程t执行完该任务以后，怎么避免终止而被复用呢？玄机就在Worker的run方法中，它不只是简单的调用了firstTask的run方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	runWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">	Thread wt = Thread.currentThread();</span><br><span class="line">	Runnable task = w.firstTask;</span><br><span class="line">	w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">	w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">	<span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			w.lock();</span><br><span class="line">			<span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">			<span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">			<span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">			<span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">			<span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">				 (Thread.interrupted() &amp;&amp;</span><br><span class="line">				  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">				!wt.isInterrupted())</span><br><span class="line">				wt.interrupt();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				beforeExecute(wt, task);</span><br><span class="line">				Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					task.run();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">					thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">					thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">					thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">				&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">					afterExecute(task, thrown);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				task = <span class="keyword">null</span>;</span><br><span class="line">				w.completedTasks++;</span><br><span class="line">				w.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		processWorkerExit(w, completedAbruptly);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 到这里可以清楚的看到，task的run方法是在一个while循环中被调用的，这个while循环就是达到复用的关键。循环条件中的getTask()就是从队列中取任务。至此才算真相大白，线程池中的每个线程，在执行完任务以后，都会循环去取队列中的任务接着执行，就是这样实现线程复用的。<br> 这里也可以注意到，除了调用task的run方法以外，还有一些额外的操作，在文章一开始提到的线程监控功能，就是在这里完成的，JDK提供了一些默认监控参数，我们也可以通过继承重写beforeExecute和afterExecute方法实现自定义的监控，比如执行时间等记录，以下是JDK提供的参数：</p>
<ul>
<li>taskCount：线程池需要执行的任务数量。</li>
<li>completedTaskCount：线程池在运行过程中已完成的任务数量。小于或等于taskCount。</li>
<li>largestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。</li>
<li>getPoolSize：线程池的线程数量。如果线程池不销毁的话，池里的线程不会自动销毁，所以这个大小只增不减。</li>
<li>getActiveCount：获取活动的线程数。</li>
</ul>
</li>
<li><p>如果你还记得前边Exexutors构造参数的话，你应该注意到我们还剩最后一个问题没有讲清楚，那就是当线程池中没有可执行的任务时，是怎么控制多余线程在Timeout时间后终止的？机智如你一定发现上图中，如果while循环条件失败，即对应没有可执行的任务，while循环之后还有一个finally语句块，玄机应该就在这个processWorkerExit方法吧：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class="line">		decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">	mainLock.lock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		completedTaskCount += w.completedTasks;</span><br><span class="line">		workers.remove(w);</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		mainLock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tryTerminate();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> c = ctl.get();</span><br><span class="line">	<span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">			<span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">			<span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">				min = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">				<span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">		&#125;</span><br><span class="line">		addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 看完这个方法的源码我是有点意外的，和我预想的处理方式完全不一样，接下来一步步讲：</p>
<ol>
<li>通过参数completedAbruptly的注释我们可以知道它==true时表示用户任务是由于用户代码抛出异常而终止的（这和runWorker方法中对其赋值是对应的），该方法做的第一件事是判断任务结束的原因，如果是因为用户代码抛出异常，那此时执行该任务的线程已经因为异常而终止了，接着decrementWorkerCount()是通过CAS执行线程个数减1操作；</li>
<li>该方法做的第二件事，加锁，把该Worker完成的任务个数，汇总到整个线程池完成的任务个数上（开个小岔，这么做难道不会造成监控参数completedTaskCount的准确性延迟吗？其实并不会，因为当我们通过get方法获取该参数时，会加锁遍历所有的Worker汇总已完成的任务个数），然后从工作线程集合HashSet中去除该Worker。是的！这里没有判断是否超时，直接删了，而且要注意，这里是通过HashSet的remove方法删的，并没有对线程个数进行修改！先别急，接着往下看；</li>
<li>该方法做的第三件事，tryTerminate()，通过该方法的注释可以了解到，这是一个任何牵扯到线程个数减少或从队列中取任务的操作都要做的保险措施，不是重点，接着往下看；</li>
<li>第四件事才是关于线程个数维护的，首先检查线程池状态，如果没有关闭，接下来的分支很有意思：a)如果用户任务是因为异常终止的，就直接通过addWorker添加一个没有任务的工作线程顶替因异常挂掉的线程；b)如果用户任务是正常运行结束的，就根据allowCoreThreadTimeOut设置最少线程个数，然后检查当前是否少于最少个数，不少的话方法就结束了，否则通过addWorker添加一个没有任务的工作线程。这里可以再回顾一下上边addWorker方法的源码，该方法新建包装了一个工作线程，然后start线程开始通过runWorker方法执行任务，但这里任务是空的，也就是runWorker方法里while循环直接结束了，然后又会回到这里，如果一直没有新任务到来的话，线程池就是这样，循环往复的创建线程，删除线程来维护线程个数的。<br>看到这，如果上边讲得你已经理解消化了，你可能还会有疑问：如果我们在线程池空闲时，在它删除一个线程之后，创建充数的线程之前，获取这个时刻的线程个数的话，会不会少于corePoolSize呢？答案是不会的！该方法唯一一处对线程个数有操作的是，当线程是异常终止时，对线程个数减1操作。其他所有情况，空闲时只是不断的创建和删除线程实体，但并没有修改线程个数。<br>这个方法看似分支很少，其实处理了很多种情况，可以通过下边的流程图梳理一下：<br><img src="http://cevxd.img47.wal8.com/img47/542077_20160404152451/145975826897.png" alt="processWorkerExit流程图"></li>
</ol>
</li>
<li><p>看到这里的时候，你如果还记得我们一开始的问题，应该会反应过来，这个processWorkerExit方法只是单纯的控制线程个数，但并没有依据keepAliveTime指定的空闲时间来裁决线程的去留啊！！我一开始也是笃定时间判断控制是在这里的！如果不在这里，那究竟在哪里呢？直接查看都有哪些方法调用过keepAliveTime参数就知道了：<br><img src="http://cevxd.img47.wal8.com/img47/542077_20160404152451/145975832373.png" alt="keepAliveTime调用"><br>通过排除法我们可以确定，原来是在被我们忽视的getTask()方法里！！真是没想到啊！这个方法其他的源码我们可以不看，只用看一行我们就什么都明白了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Runnable r = timed ?</span><br><span class="line">	workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">	workQueue.take();</span><br></pre></td></tr></table></figure>
<p>原来是在从队列中取任务的时候做到时间控制的！一开始我们可能是想不到的，但看到这里，仔细一想，放在这里真是再合适不过了：当一个线程在取任务的时候，说明这个线程是空闲的，当它从队列中取任务超时而失败的时候，它就已经超过了空闲时间上限了，这时候的流程是：runWorker方法中的while循环条件失败，走进processWorkerExit方法做最后的线程个数控制，简直完美！</p>
</li>
<li>参考<ol>
<li><a href="http://ifeve.com/java-threadpool/" target="_blank" rel="external">http://ifeve.com/java-threadpool/</a></li>
<li><a href="http://blog.csdn.net/it_man/article/details/7193727" target="_blank" rel="external">http://blog.csdn.net/it_man/article/details/7193727</a></li>
<li><a href="http://www.oschina.net/question/565065_86540" target="_blank" rel="external">http://www.oschina.net/question/565065_86540</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-jtp0730/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/java/j-jtp0730/</a></li>
</ol>
</li>
</ol>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/head.png"
               alt="ksni88" />
          <p class="site-author-name" itemprop="name">ksni88</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
            <div class="links-of-blogroll-title">Links</div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://cruise1008.github.io/" target="_blank">海神</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://moonfacex.github.io/blog/" target="_blank">杭城梦少</a>
                </li>
              
            </ul>
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ksni88</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=0.5.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"ksni88"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      <script src="/vendors/ua-parser-js/dist/ua-parser.min.js"></script>
      <script src="/js/src/hook-duoshuo.js"></script>
    
  





  
  
  

  

  

</body>
</html>
